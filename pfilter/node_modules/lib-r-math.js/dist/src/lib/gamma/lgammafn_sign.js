"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var trigonometry_1 = require("../trigonometry");
var gamma_fn_1 = require("./gamma_fn");
var lgammacor_1 = require("./lgammacor");
var ISNAN = Number.isNaN, ML_POSINF = Number.POSITIVE_INFINITY;
var log = Math.log, fabs = Math.abs, floor = Math.floor, trunc = Math.trunc;
var printer_sign = debug('lgammafn_sign');
var xmax = 2.5327372760800758e305;
var dxrel = 1.490116119384765625e-8;
function lgammafn_sign(x, sgn) {
    var ans;
    var y;
    var sinpiy;
    if (sgn)
        sgn[0] = 1;
    if (ISNAN(x))
        return x;
    if (sgn && x < 0 && _general_1.fmod(floor(-x), 2) === 0) {
        sgn[0] = -1;
    }
    if (x <= 0 && x === trunc(x)) {
        _general_1.ML_ERROR(_general_1.ME.ME_RANGE, 'lgamma', printer_sign);
        return ML_POSINF;
    }
    y = fabs(x);
    if (y < 1e-306)
        return -log(y);
    if (y <= 10)
        return log(fabs(gamma_fn_1.gammafn(x)));
    if (y > xmax) {
        _general_1.ML_ERROR(_general_1.ME.ME_RANGE, 'lgamma', printer_sign);
        return ML_POSINF;
    }
    if (x > 0) {
        if (x > 1e17)
            return x * (log(x) - 1);
        else if (x > 4934720)
            return _general_1.M_LN_SQRT_2PI + (x - 0.5) * log(x) - x;
        else
            return _general_1.M_LN_SQRT_2PI + (x - 0.5) * log(x) - x + lgammacor_1.lgammacor(x);
    }
    sinpiy = fabs(trigonometry_1.sinpi(y));
    if (sinpiy === 0) {
        printer_sign(' ** should NEVER happen! *** [lgamma.c: Neg.int, y=%d]', y);
        return _general_1.ML_ERR_return_NAN(printer_sign);
    }
    ans = _general_1.M_LN_SQRT_PId2 + (x - 0.5) * log(y) - x - log(sinpiy) - lgammacor_1.lgammacor(y);
    if (fabs((x - Math.trunc(x - 0.5)) * ans / x) < dxrel) {
        _general_1.ML_ERROR(_general_1.ME.ME_PRECISION, 'lgamma', printer_sign);
    }
    return ans;
}
exports.lgammafn_sign = lgammafn_sign;
//# sourceMappingURL=lgammafn_sign.js.map