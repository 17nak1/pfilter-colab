"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var expm1_1 = require("../exp/expm1");
var dgamma_1 = require("../gamma/dgamma");
var lgammafn_sign_1 = require("../gamma/lgammafn_sign");
var pgamma_1 = require("../gamma/pgamma");
var pgamma_2 = require("./pgamma");
var pgamma_3 = require("./pgamma");
var qnorm_1 = require("../normal/qnorm");
var isArray = Array.isArray;
var fabs = Math.abs, sqrt = Math.sqrt, pow = Math.pow, exp = Math.exp, log = Math.log;
var ISNAN = Number.isNaN, ML_POSINF = Number.POSITIVE_INFINITY, ML_NEGINF = Number.NEGATIVE_INFINITY, DBL_MIN = Number.MIN_VALUE, R_FINITE = Number.isFinite;
var printer_qchisq_appr = debug('qchisq_appr');
function qchisq_appr(p, nu, g, lower_tail, log_p, tol) {
    var C7 = 4.67;
    var C8 = 6.66;
    var C9 = 6.73;
    var C10 = 13.32;
    var alpha;
    var a;
    var c;
    var ch;
    var p1;
    var p2;
    var q;
    var t;
    var x;
    if (ISNAN(p) || ISNAN(nu))
        return p + nu;
    var rc = _general_1.R_Q_P01_check(log_p, p);
    if (rc !== undefined) {
        return rc;
    }
    if (nu <= 0) {
        return _general_1.ML_ERR_return_NAN(printer_qchisq_appr);
    }
    alpha = 0.5 * nu;
    c = alpha - 1;
    if (nu < -1.24 * (p1 = expm1_1.R_DT_log(lower_tail, log_p, p))) {
        var lgam1pa = alpha < 0.5 ? pgamma_3.lgamma1p(alpha) : log(alpha) + g;
        ch = exp((lgam1pa + p1) / alpha + _general_1.M_LN2);
        printer_qchisq_appr(' small chi-sq., ch0 = %d', ch);
    }
    else if (nu > 0.32) {
        x = qnorm_1.qnorm(p, 0, 1, lower_tail, log_p);
        p1 = 2 / (9 * nu);
        ch = nu * pow(x * sqrt(p1) + 1 - p1, 3);
        printer_qchisq_appr(' nu > .32: Wilson-Hilferty; x = %d', x);
        if (ch > 2.2 * nu + 6)
            ch = -2 * (expm1_1.R_DT_Clog(lower_tail, log_p, p) - c * log(0.5 * ch) + g);
    }
    else {
        ch = 0.4;
        a = expm1_1.R_DT_Clog(lower_tail, log_p, p) + g + c * _general_1.M_LN2;
        printer_qchisq_appr(' nu <= .32: a = %d', a);
        do {
            q = ch;
            p1 = 1 / (1 + ch * (C7 + ch));
            p2 = ch * (C9 + ch * (C8 + ch));
            t = -0.5 + (C7 + 2 * ch) * p1 - (C9 + ch * (C10 + 3 * ch)) / p2;
            ch -= (1 - exp(a + 0.5 * ch) * p2 * p1) / t;
        } while (fabs(q - ch) > tol * fabs(ch));
    }
    return ch;
}
exports.qchisq_appr = qchisq_appr;
function qgamma(p, alpha, scale, lowerTail, logP) {
    if (alpha === void 0) { alpha = 1; }
    if (scale === void 0) { scale = 1; }
    if (lowerTail === void 0) { lowerTail = true; }
    if (logP === void 0) { logP = false; }
    var fa = isArray(p) ? p : [p];
    var result = fa.map(function (pp) {
        return _qgamma(pp, alpha, scale, lowerTail, logP);
    });
    return result.length === 1 ? result[0] : result;
}
exports.qgamma = qgamma;
var printer_qgamma = debug('_qgamma');
function _qgamma(p, alpha, scale, lower_tail, log_p) {
    if (alpha === void 0) { alpha = 1; }
    if (scale === void 0) { scale = 1 / alpha; }
    if (lower_tail === void 0) { lower_tail = true; }
    if (log_p === void 0) { log_p = false; }
    var EPS1 = 1e-2;
    var EPS2 = 5e-7;
    var EPS_N = 1e-15;
    var MAXIT = 1000;
    var pMIN = 1e-100;
    var pMAX = 1 - 1e-14;
    var i420 = 1 / 420;
    var i2520 = 1 / 2520;
    var i5040 = 1 / 5040;
    var p_;
    var a;
    var b;
    var c;
    var g;
    var ch;
    var ch0;
    var p1;
    var p2;
    var s1;
    var s2;
    var s3;
    var s4;
    var s5;
    var s6;
    var t;
    var x;
    var i;
    var max_it_Newton = 1;
    var q = 0;
    var goto_END = false;
    if (ISNAN(p) || ISNAN(alpha) || ISNAN(scale))
        return p + alpha + scale;
    var rc = _general_1.R_Q_P01_boundaries(lower_tail, log_p, p, 0, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    if (alpha < 0 || scale <= 0)
        return _general_1.ML_ERR_return_NAN(printer_qgamma);
    if (alpha === 0)
        return 0;
    if (alpha < 1e-10) {
        printer_qgamma('value of shape (%d) is extremely small: results may be unreliable', alpha);
        max_it_Newton = 7;
    }
    p_ = expm1_1.R_DT_qIv(lower_tail, log_p, p);
    printer_qgamma('qgamma(p=%d, alpha=%d, scale=%d, l.t.=%s, log_p=%s): ', p, alpha, scale, lower_tail, log_p);
    g = lgammafn_sign_1.lgammafn_sign(alpha);
    ch = qchisq_appr(p, 2 * alpha, g, lower_tail, log_p, EPS1);
    if (!R_FINITE(ch)) {
        max_it_Newton = 0;
        goto_END = true;
    }
    if (goto_END === false) {
        if (ch < EPS2) {
            max_it_Newton = 20;
            goto_END = true;
        }
    }
    if (goto_END === false) {
        if (p_ > pMAX || p_ < pMIN) {
            max_it_Newton = 20;
            goto_END = true;
        }
    }
    if (goto_END === false) {
        printer_qgamma('\t==> ch = %d:', ch);
        c = alpha - 1;
        s6 = (120 + c * (346 + 127 * c)) * i5040;
        ch0 = ch;
        for (i = 1; i <= MAXIT; i++) {
            q = ch;
            p1 = 0.5 * ch;
            p2 =
                p_ -
                    pgamma_2.pgamma_raw(p1, alpha, true, false);
            if (i === 1)
                printer_qgamma(' Ph.II iter; ch=%d, p2=%d', ch, p2);
            if (i >= 2)
                printer_qgamma('     it=%d,  ch=%d, p2=%d', i, ch, p2);
            if (!R_FINITE(p2) || ch <= 0) {
                ch = ch0;
                max_it_Newton = 27;
                goto_END = true;
                break;
            }
            t = p2 * exp(alpha * _general_1.M_LN2 + g + p1 - c * log(ch));
            b = t / ch;
            a = 0.5 * t - b * c;
            s1 = (210 + a * (140 + a * (105 + a * (84 + a * (70 + 60 * a))))) * i420;
            s2 = (420 + a * (735 + a * (966 + a * (1141 + 1278 * a)))) * i2520;
            s3 = (210 + a * (462 + a * (707 + 932 * a))) * i2520;
            s4 =
                (252 + a * (672 + 1182 * a) + c * (294 + a * (889 + 1740 * a))) * i5040;
            s5 = (84 + 2264 * a + c * (1175 + 606 * a)) * i2520;
            ch +=
                t *
                    (1 +
                        0.5 * t * s1 -
                        b * c * (s1 - b * (s2 - b * (s3 - b * (s4 - b * (s5 - b * s6))))));
            if (fabs(q - ch) < EPS2 * ch) {
                goto_END = true;
                break;
            }
            if (fabs(q - ch) > 0.1 * ch) {
                if (ch < q)
                    ch = 0.9 * q;
                else
                    ch = 1.1 * q;
            }
        }
        printer_qgamma('qgamma(%d) not converged in %d iterations; rel.ch=%d', p, MAXIT, ch / fabs(q - ch));
    }
    x = 0.5 * scale * ch;
    if (max_it_Newton) {
        if (!log_p) {
            p = log(p);
            log_p = true;
        }
        if (x === 0) {
            var _1_p = 1 + 1e-7;
            var _1_m = 1 - 1e-7;
            x = DBL_MIN;
            p_ = pgamma_1.pgamma(x, alpha, scale, lower_tail, log_p);
            if ((lower_tail && p_ > p * _1_p) || (!lower_tail && p_ < p * _1_m))
                return 0;
        }
        else
            p_ = pgamma_1.pgamma(x, alpha, scale, lower_tail, log_p);
        if (p_ === ML_NEGINF)
            return 0;
        for (i = 1; i <= max_it_Newton; i++) {
            p1 = p_ - p;
            if (i === 1)
                printer_qgamma(' it=%d: p=%d, x = %d, p.=%d; p1=d{p}=%d', i, p, x, p_, p1);
            if (i >= 2)
                printer_qgamma('          x{it= %d} = %d, p.=%d, p1=d{p}=%d', i, x, p_, p1);
            if (fabs(p1) < fabs(EPS_N * p))
                break;
            g = dgamma_1.dgamma(x, alpha, scale, log_p);
            if (g === _general_1.R_D__0(log_p)) {
                if (i === 1)
                    printer_qgamma('no final Newton step because dgamma(*)== 0!');
                break;
            }
            t = log_p ? p1 * exp(p_ - g) : p1 / g;
            t = lower_tail ? x - t : x + t;
            p_ = pgamma_1.pgamma(t, alpha, scale, lower_tail, log_p);
            if (fabs(p_ - p) > fabs(p1) ||
                (i > 1 && fabs(p_ - p) === fabs(p1))) {
                if (i === 1 && max_it_Newton > 1)
                    printer_qgamma('no Newton step done since delta{p} >= last delta');
                break;
            }
            if (t > 1.1 * x)
                t = 1.1 * x;
            else if (t < 0.9 * x)
                t = 0.9 * x;
            x = t;
        }
    }
    return x;
}
exports._qgamma = _qgamma;
//# sourceMappingURL=qgamma.js.map