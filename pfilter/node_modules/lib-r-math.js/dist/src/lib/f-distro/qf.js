"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var qbeta_1 = require("../beta/qbeta");
var qchisq_1 = require("../chi-2/qchisq");
var printer = debug('qf');
var ISNAN = Number.isNaN, R_FINITE = Number.isFinite, ML_NAN = Number.NaN, ML_POSINF = Number.POSITIVE_INFINITY, ML_VALID = Number.isFinite;
function qf(pp, df1, df2, lower_tail, log_p) {
    var fp = Array.isArray(pp) ? pp : [pp];
    var result = fp.map(function (p) {
        if (ISNAN(p) || ISNAN(df1) || ISNAN(df2))
            return p + df1 + df2;
        if (df1 <= 0 || df2 <= 0)
            return _general_1.ML_ERR_return_NAN(printer);
        var rc = _general_1.R_Q_P01_boundaries(lower_tail, log_p, p, 0, ML_POSINF);
        if (rc !== undefined) {
            return rc;
        }
        if (df1 <= df2 && df2 > 4e5) {
            if (!R_FINITE(df1))
                return 1;
            return qchisq_1.qchisq(p, df1, lower_tail, log_p) / df1;
        }
        if (df1 > 4e5) {
            return df2 / qchisq_1.qchisq(p, df2, !lower_tail, log_p);
        }
        p = (1 / qbeta_1.qbeta(p, df2 / 2, df1 / 2, !lower_tail, log_p) - 1) * (df2 / df1);
        return ML_VALID(p) ? p : ML_NAN;
    });
    return result.length === 1 ? result[0] : result;
}
exports.qf = qf;
//# sourceMappingURL=qf.js.map