"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var rbinom_1 = require("../binomial/rbinom");
var _general_1 = require("../common/_general");
var qhyper_1 = require("./qhyper");
var log = Math.log, R_forceint = Math.round, exp = Math.exp, sqrt = Math.sqrt;
var R_FINITE = Number.isFinite, INT_MAX = Number.MAX_SAFE_INTEGER;
var printer_afc = debug('afc');
function afc(i) {
    var al = [
        0.0,
        0.0,
        0.69314718055994530941723212145817,
        1.7917594692280550008124773583807,
        3.17805383034794561964694160129705,
        4.78749174278204599424770093452324,
        6.57925121201010099506017829290394,
        8.52516136106541430016553103634712
    ];
    if (i < 0) {
        printer_afc('rhyper.c: afc(i), i=%d < 0 -- SHOULD NOT HAPPEN!', i);
        return -1;
    }
    if (i <= 7) {
        return al[i];
    }
    var di = i;
    var i2 = di * di;
    return ((di + 0.5) * log(di) -
        di +
        _general_1.M_LN_SQRT_2PI +
        (0.0833333333333333 - 0.00277777777777778 / i2) / di);
}
exports.afc = afc;
function rhyper(N, nn1in, nn2in, kkin, rng) {
    return Array.from({ length: N }).map(function () { return rhyperOne(nn1in, nn2in, kkin, rng); });
}
exports.rhyper = rhyper;
var printer_rhyper = debug('_rhyper');
function rhyperOne(nn1in, nn2in, kkin, rng) {
    var nn1 = 0;
    var nn2 = 0;
    var kk = 0;
    var ix = 0;
    var setup1 = false;
    var setup2 = false;
    var ks = -1;
    var n1s = -1;
    var n2s = -1;
    var m = 0;
    var minjx = 0;
    var maxjx = 0;
    var k = 0;
    var n1 = 0;
    var n2 = 0;
    var tn = 0;
    var w = 0;
    var a = 0;
    var d = 0;
    var s = 0;
    var xl = 0;
    var xr = 0;
    var kl = 0;
    var kr = 0;
    var lamdl = 0;
    var lamdr = 0;
    var p1 = 0;
    var p2 = 0;
    var p3 = 0;
    if (!R_FINITE(nn1in) || !R_FINITE(nn2in) || !R_FINITE(kkin))
        return _general_1.ML_ERR_return_NAN(printer_rhyper);
    nn1in = R_forceint(nn1in);
    nn2in = R_forceint(nn2in);
    kkin = R_forceint(kkin);
    if (nn1in < 0 || nn2in < 0 || kkin < 0 || kkin > nn1in + nn2in)
        return _general_1.ML_ERR_return_NAN(printer_rhyper);
    if (nn1in >= INT_MAX || nn2in >= INT_MAX || kkin >= INT_MAX) {
        if (kkin === 1) {
            return rbinom_1.rbinomOne(kkin, nn1in / (nn1in + nn2in), rng);
        }
        return qhyper_1.qhyper(rng.unif_rand(), nn1in, nn2in, kkin, false, false);
    }
    nn1 = nn1in;
    nn2 = nn2in;
    kk = kkin;
    if (nn1 !== n1s || nn2 !== n2s) {
        setup1 = true;
        setup2 = true;
    }
    else if (kk !== ks) {
        setup1 = false;
        setup2 = true;
    }
    else {
        setup1 = false;
        setup2 = false;
    }
    if (setup1) {
        n1s = nn1;
        n2s = nn2;
        tn = nn1 + nn2;
        if (nn1 <= nn2) {
            n1 = nn1;
            n2 = nn2;
        }
        else {
            n1 = nn2;
            n2 = nn1;
        }
    }
    if (setup2) {
        ks = kk;
        if (kk + kk >= tn) {
            k = tn - kk;
        }
        else {
            k = kk;
        }
    }
    if (setup1 || setup2) {
        m = (k + 1) * (n1 + 1) / (tn + 2);
        minjx = _general_1.imax2(0, k - n2);
        maxjx = _general_1.imin2(n1, k);
        printer_rhyper('rhyper(nn1=%d, nn2=%d, kk=%d), setup: floor(mean)= m=%d, jx in (%d..%d)', nn1, nn2, kk, m, minjx, maxjx);
    }
    if (minjx === maxjx) {
        printer_rhyper('rhyper(), branch I (degenerate)');
        ix = maxjx;
    }
    else if (m - minjx < 10) {
        var scale = 1e25;
        var con = 57.5646273248511421;
        if (setup1 || setup2) {
            var lw = void 0;
            if (k < n2) {
                lw = afc(n2) + afc(n1 + n2 - k) - afc(n2 - k) - afc(n1 + n2);
            }
            else {
                lw = afc(n1) + afc(k) - afc(k - n2) - afc(n1 + n2);
            }
            w = exp(lw + con);
        }
        var p = 0;
        var u = 0;
        printer_rhyper('rhyper(), branch II; w = %d > 0', w);
        var goto_L10 = false;
        while (true) {
            p = w;
            ix = minjx;
            u = rng.unif_rand() * scale;
            printer_rhyper('  _new_ u = %d', u);
            while (u > p) {
                u -= p;
                p *= (n1 - ix) * (k - ix);
                ix++;
                p = p / ix / (n2 - k + ix);
                printer_rhyper('       ix=%d, u=%d, p=%d (u-p=%d)\n', ix, u, p, u - p);
                if (ix > maxjx) {
                    goto_L10 = true;
                    break;
                }
            }
            if (!goto_L10) {
                break;
            }
        }
    }
    else {
        if (setup1 || setup2) {
            s = sqrt((tn - k) * k * n1 * n2 / (tn - 1) / tn / tn);
            d = 1.5 * s + 0.5;
            xl = m - d + 0.5;
            xr = m + d + 0.5;
            a = afc(m) + afc(n1 - m) + afc(k - m) + afc(n2 - k + m);
            kl = exp(a - afc(xl) - afc(n1 - xl) - afc(k - xl) - afc(n2 - k + xl));
            kr = exp(a -
                afc(xr - 1) -
                afc(n1 - xr + 1) -
                afc(k - xr + 1) -
                afc(n2 - k + xr - 1));
            lamdl = -log(xl * (n2 - k + xl) / (n1 - xl + 1) / (k - xl + 1));
            lamdr = -log((n1 - xr + 1) * (k - xr + 1) / xr / (n2 - k + xr));
            p1 = d + d;
            p2 = p1 + kl / lamdl;
            p3 = p2 + kr / lamdr;
        }
        printer_rhyper('rhyper(), branch III {accept/reject}: (xl,xr)= (%d,%d); (lamdl,lamdr)= (%d,%d)\n', xl, xr, lamdl, lamdr);
        printer_rhyper('-------- p123= c(%d,%d,%d)\n', p1, p2, p3);
        var n_uv = 0;
        while (true) {
            var u = rng.unif_rand() * p3;
            var v = rng.unif_rand();
            n_uv++;
            if (n_uv >= 10000) {
                printer_rhyper('rhyper() branch III: giving up after %d rejections', n_uv);
                return _general_1.ML_ERR_return_NAN(printer_rhyper);
            }
            printer_rhyper(' ... L30: new (u=%d, v ~ U[0,1])[%d]\n', u, n_uv);
            if (u < p1) {
                ix = xl + u;
            }
            else if (u <= p2) {
                ix = xl + log(v) / lamdl;
                if (ix < minjx) {
                    continue;
                }
                v = v * (u - p1) * lamdl;
            }
            else {
                ix = xr - log(v) / lamdr;
                if (ix > maxjx) {
                    continue;
                }
                v = v * (u - p2) * lamdr;
            }
            var reject = true;
            if (m < 100 || ix <= 50) {
                var i = void 0;
                var f = 1.0;
                if (m < ix) {
                    for (i = m + 1; i <= ix; i++)
                        f = f * (n1 - i + 1) * (k - i + 1) / (n2 - k + i) / i;
                }
                else if (m > ix) {
                    for (i = ix + 1; i <= m; i++)
                        f = f * i * (n2 - k + i) / (n1 - i + 1) / (k - i + 1);
                }
                if (v <= f) {
                    reject = false;
                }
            }
            else {
                var deltal = 0.0078;
                var deltau = 0.0034;
                var e = void 0;
                var g = void 0;
                var r = void 0;
                var t = void 0;
                var y = void 0;
                var de = void 0;
                var dg = void 0;
                var dr = void 0;
                var ds = void 0;
                var dt = void 0;
                var gl = void 0;
                var gu = void 0;
                var nk = void 0;
                var nm = void 0;
                var ub = void 0;
                var xk = void 0;
                var xm = void 0;
                var xn = void 0;
                var y1 = void 0;
                var ym = void 0;
                var yn = void 0;
                var yk = void 0;
                var alv = void 0;
                printer_rhyper(" ... accept/reject 'large' case v=%d", v);
                y = ix;
                y1 = y + 1.0;
                ym = y - m;
                yn = n1 - y + 1.0;
                yk = k - y + 1.0;
                nk = n2 - k + y1;
                r = -ym / y1;
                s = ym / yn;
                t = ym / yk;
                e = -ym / nk;
                g = yn * yk / (y1 * nk) - 1.0;
                dg = 1.0;
                if (g < 0.0)
                    dg = 1.0 + g;
                gu = g * (1.0 + g * (-0.5 + g / 3.0));
                gl = gu - 0.25 * (g * g * g * g) / dg;
                xm = m + 0.5;
                xn = n1 - m + 0.5;
                xk = k - m + 0.5;
                nm = n2 - k + xm;
                ub =
                    y * gu -
                        m * gl +
                        deltau +
                        xm * r * (1 + r * (-0.5 + r / 3.0)) +
                        xn * s * (1 + s * (-0.5 + s / 3.0)) +
                        xk * t * (1 + t * (-0.5 + t / 3.0)) +
                        nm * e * (1 + e * (-0.5 + e / 3.0));
                alv = log(v);
                if (alv > ub) {
                    reject = true;
                }
                else {
                    dr = xm * (r * r * r * r);
                    if (r < 0.0)
                        dr /= 1.0 + r;
                    ds = xn * (s * s * s * s);
                    if (s < 0.0)
                        ds /= 1.0 + s;
                    dt = xk * (t * t * t * t);
                    if (t < 0.0)
                        dt /= 1.0 + t;
                    de = nm * (e * e * e * e);
                    if (e < 0.0)
                        de /= 1.0 + e;
                    if (alv <
                        ub - 0.25 * (dr + ds + dt + de) + (y + m) * (gl - gu) - deltal) {
                        reject = false;
                    }
                    else {
                        if (alv <=
                            a - afc(ix) - afc(n1 - ix) - afc(k - ix) - afc(n2 - k + ix)) {
                            reject = false;
                        }
                        else {
                            reject = true;
                        }
                    }
                }
            }
            if (reject) {
                continue;
            }
            break;
        }
    }
    if (kk + kk >= tn) {
        if (nn1 > nn2) {
            ix = kk - nn2 + ix;
        }
        else {
            ix = nn1 - ix;
        }
    }
    else {
        if (nn1 > nn2)
            ix = kk - ix;
    }
    return ix;
}
//# sourceMappingURL=rhyper.js.map