"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var cospi_1 = require("../../trigonometry/cospi");
var sinpi_1 = require("../../trigonometry/sinpi");
var bessel_constants_1 = require("../bessel-constants");
var M_SQRT_2dPI = 0.797884560802865355879892119869;
var M_1_PI = 0.3183098861837907;
var M_PI_2 = 1.5707963267948966;
var min = Math.min, trunc = Math.trunc, sqrt = Math.sqrt, sin = Math.sin, cos = Math.cos, log = Math.log, abs = Math.abs, pow = Math.pow, M_PI = Math.PI;
var DBL_MIN = Number.MIN_VALUE, DBL_EPSILON = Number.EPSILON, ML_NEGINF = Number.NEGATIVE_INFINITY, DBL_MAX = Number.MAX_VALUE;
var printer = debug('Y_bessel');
function Y_bessel(x, alpha, nb) {
    var fivpi = 15.707963267948966192;
    var pim5 = .70796326794896619231;
    var ch = [-6.7735241822398840964e-24,
        -6.1455180116049879894e-23, 2.9017595056104745456e-21,
        1.3639417919073099464e-19, 2.3826220476859635824e-18,
        -9.0642907957550702534e-18, -1.4943667065169001769e-15,
        -3.3919078305362211264e-14, -1.7023776642512729175e-13,
        9.1609750938768647911e-12, 2.4230957900482704055e-10,
        1.7451364971382984243e-9, -3.3126119768180852711e-8,
        -8.6592079961391259661e-7, -4.9717367041957398581e-6,
        7.6309597585908126618e-5, .0012719271366545622927,
        .0017063050710955562222, -.07685284084478667369,
        -.28387654227602353814, .92187029365045265648];
    var i;
    var k;
    var na;
    var ncalc;
    var alfa;
    var div;
    var ddiv;
    var even;
    var gamma;
    var term;
    var cosmu;
    var sinmu;
    var b;
    var c;
    var d;
    var e;
    var f;
    var g;
    var h;
    var p;
    var q;
    var r;
    var s;
    var d1;
    var d2;
    var q0;
    var pa;
    var pa1;
    var qa;
    var qa1;
    var en;
    var ya;
    var ya1;
    var twobyx;
    var den;
    var odd;
    var aye;
    var dmu;
    var x2;
    var xna;
    var en1 = ya = ya1 = 0;
    var ex = x;
    var nu = alpha;
    var by = new Array(nb).fill(0);
    if (!(nb > 0 && 0. <= nu && nu < 1.)) {
        printer('violaton: abort nb=%d, nu=%d', nb, nu);
        by[0] = 0.;
        ncalc = min(nb, 0) - 1;
        return { x: 0, nb: nb, ncalc: ncalc };
    }
    if (ex < DBL_MIN || ex > bessel_constants_1.xlrg_BESS_Y) {
        printer('range issue: x < DBL_MIN but still bigger then 1e8 x=(%d)', ex);
        ncalc = nb;
        if (ex > bessel_constants_1.xlrg_BESS_Y)
            by[0] = 0.;
        else if (ex < DBL_MIN)
            by[0] = ML_NEGINF;
        return { x: by[0], nb: nb, ncalc: ncalc };
    }
    xna = trunc(nu + .5);
    na = trunc(xna);
    if (na === 1) {
        nu -= xna;
    }
    if (nu === -.5) {
        p = M_SQRT_2dPI / sqrt(ex);
        ya = p * sin(ex);
        ya1 = -p * cos(ex);
    }
    else if (ex < 3.) {
        b = ex * .5;
        d = -log(b);
        f = nu * d;
        e = pow(b, -nu);
        if (abs(nu) < bessel_constants_1.M_eps_sinc)
            c = M_1_PI;
        else
            c = nu / sinpi_1.sinpi(nu);
        if (abs(f) < 1.) {
            x2 = f * f;
            en = 19.;
            s = 1.;
            for (i = 1; i <= 9; ++i) {
                s = s * x2 / en / (en - 1.) + 1.;
                en -= 2.;
            }
        }
        else {
            s = (e - 1. / e) * .5 / f;
        }
        x2 = nu * nu * 8.;
        aye = ch[0];
        even = 0.;
        alfa = ch[1];
        odd = 0.;
        for (i = 3; i <= 19; i += 2) {
            even = -(aye + aye + even);
            aye = -even * x2 - aye + ch[i - 1];
            odd = -(alfa + alfa + odd);
            alfa = -odd * x2 - alfa + ch[i];
        }
        even = (even * .5 + aye) * x2 - aye + ch[20];
        odd = (odd + alfa) * 2.;
        gamma = odd * nu + even;
        g = e * gamma;
        e = (e + 1. / e) * .5;
        f = 2. * c * (odd * e + even * s * d);
        e = nu * nu;
        p = g * c;
        q = M_1_PI / g;
        c = nu * M_PI_2;
        if (abs(c) < bessel_constants_1.M_eps_sinc)
            r = 1.;
        else
            r = sinpi_1.sinpi(nu / 2) / c;
        r = M_PI * c * r * r;
        c = 1.;
        d = -b * b;
        h = 0.;
        ya = f + r * q;
        ya1 = p;
        en = 1.;
        while (abs(g / (1. + abs(ya))) +
            abs(h / (1. + abs(ya1))) > DBL_EPSILON) {
            f = (f * en + p + q) / (en * en - e);
            c *= (d / en);
            p /= en - nu;
            q /= en + nu;
            g = c * (f + r * q);
            h = c * p - en * g;
            ya += g;
            ya1 += h;
            en += 1.;
        }
        ya = -ya;
        ya1 = -ya1 / b;
    }
    else if (ex < bessel_constants_1.thresh_BESS_Y) {
        c = (.5 - nu) * (.5 + nu);
        b = ex + ex;
        e = ex * M_1_PI * cospi_1.cospi(nu) / DBL_EPSILON;
        e *= e;
        p = 1.;
        q = -ex;
        r = 1. + ex * ex;
        s = r;
        en = 2.;
        while (r * en * en < e) {
            en1 = en + 1.;
            d = (en - 1. + c / en) / s;
            p = (en + en - p * d) / en1;
            q = (-b + q * d) / en1;
            s = p * p + q * q;
            r *= s;
            en = en1;
        }
        f = p / s;
        p = f;
        g = -q / s;
        q = g;
        for (;;) {
            en -= 1.;
            if (en > 0.) {
                r = en1 * (2. - p) - 2.;
                s = b + en1 * q;
                d = (en - 1. + c / en) / (r * r + s * s);
                p = d * r;
                q = d * s;
                e = f + 1.;
                f = p * e - g * q;
                g = q * e + p * g;
                en1 = en;
                continue;
            }
            break;
        }
        f = 1. + f;
        d = f * f + g * g;
        pa = f / d;
        qa = -g / d;
        d = nu + .5 - p;
        q += ex;
        pa1 = (pa * q - qa * d) / ex;
        qa1 = (qa * q + pa * d) / ex;
        b = ex - M_PI_2 * (nu + .5);
        c = cos(b);
        s = sin(b);
        d = M_SQRT_2dPI / sqrt(ex);
        ya = d * (pa * s + qa * c);
        ya1 = d * (qa1 * s - pa1 * c);
    }
    else {
        na = 0;
        d1 = trunc(ex / fivpi);
        i = trunc(d1);
        dmu = ex - 15. * d1 - d1 * pim5 - (alpha + .5) * M_PI_2;
        if (i - (i / 2 << 1) === 0) {
            cosmu = cos(dmu);
            sinmu = sin(dmu);
        }
        else {
            cosmu = -cos(dmu);
            sinmu = -sin(dmu);
        }
        ddiv = 8. * ex;
        dmu = alpha;
        den = sqrt(ex);
        for (k = 1; k <= 2; ++k) {
            p = cosmu;
            cosmu = sinmu;
            sinmu = -p;
            d1 = (2. * dmu - 1.) * (2. * dmu + 1.);
            d2 = 0.;
            div = ddiv;
            p = 0.;
            q = 0.;
            q0 = d1 / div;
            term = q0;
            for (i = 2; i <= 20; ++i) {
                d2 += 8.;
                d1 -= d2;
                div += ddiv;
                term = -term * d1 / div;
                p += term;
                d2 += 8.;
                d1 -= d2;
                div += ddiv;
                term *= (d1 / div);
                q += term;
                if (abs(term) <= DBL_EPSILON) {
                    break;
                }
            }
            p += 1.;
            q += q0;
            if (k === 1)
                ya = M_SQRT_2dPI * (p * cosmu - q * sinmu) / den;
            else
                ya1 = M_SQRT_2dPI * (p * cosmu - q * sinmu) / den;
            dmu += 1.;
        }
    }
    if (na === 1) {
        h = 2. * (nu + 1.) / ex;
        if (h > 1.) {
            if (abs(ya1) > DBL_MAX / h) {
                h = 0.;
                ya = 0.;
            }
        }
        h = h * ya1 - ya;
        ya = ya1;
        ya1 = h;
    }
    by[0] = ya;
    ncalc = 1;
    if (nb > 1) {
        by[1] = ya1;
        if (ya1 !== 0.) {
            aye = 1. + alpha;
            twobyx = 2. / ex;
            ncalc = 2;
            for (i = 2; i < nb; ++i) {
                if (twobyx < 1.) {
                    if (abs(by[i - 1]) * twobyx >= DBL_MAX / aye)
                        break;
                }
                else {
                    if (abs(by[i - 1]) >= DBL_MAX / aye / twobyx)
                        break;
                }
                by[i] = twobyx * aye * by[i - 1] - by[i - 2];
                aye += 1.;
                ++(ncalc);
            }
        }
    }
    return { x: by[ncalc - 1], nb: nb, ncalc: ncalc };
}
exports.Y_bessel = Y_bessel;
//# sourceMappingURL=Ybessel.js.map