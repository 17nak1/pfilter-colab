"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../../common/_general");
var sinpi_1 = require("../../trigonometry/sinpi");
var besselK_1 = require("../besselK");
var IBessel_1 = require("./IBessel");
var ISNAN = Number.isNaN;
var exp = Math.exp, trunc = Math.trunc, floor = Math.floor, M_PI = Math.PI;
var printer = debug('bessel_i');
function bessel_i(x, alpha, expo) {
    if (expo === void 0) { expo = false; }
    var nb;
    var ize;
    var na;
    if (ISNAN(x) || ISNAN(alpha))
        return x + alpha;
    if (x < 0) {
        _general_1.ML_ERROR(_general_1.ME.ME_RANGE, 'bessel_i', printer);
        return NaN;
    }
    ize = expo ? 2 : 1;
    na = floor(alpha);
    if (alpha < 0) {
        return (bessel_i(x, -alpha, expo) +
            ((alpha === na) ? 0 :
                besselK_1.bessel_k(x, -alpha, expo) *
                    ((ize === 1) ? 2. : 2. * exp(-2. * x)) / M_PI * sinpi_1.sinpi(-alpha)));
    }
    nb = 1 + trunc(na);
    alpha -= (nb - 1);
    var rc = IBessel_1.I_bessel(x, alpha, nb, ize);
    if (rc.ncalc !== rc.nb) {
        if (rc.ncalc < 0)
            printer('bessel_i(%d): ncalc (=%d) != nb (=%d); alpha=%d. Arg. out of range?', x, rc.ncalc, rc.nb, alpha);
        else
            printer('bessel_i(%d,nu=%d): precision lost in result\n', rc.x, alpha + rc.nb - 1);
    }
    x = rc.x;
    return x;
}
exports.bessel_i = bessel_i;
//# sourceMappingURL=index.js.map