"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../../common/_general");
var cospi_1 = require("../../trigonometry/cospi");
var sinpi_1 = require("../../trigonometry/sinpi");
var besselY_1 = require("../besselY");
var Jbessel_1 = require("./Jbessel");
var ISNAN = Number.isNaN;
var floor = Math.floor, trunc = Math.trunc;
var printer = debug('bessel_j');
function bessel_j(x, alpha) {
    var nb;
    var na;
    if (ISNAN(x) || ISNAN(alpha))
        return x + alpha;
    if (x < 0) {
        _general_1.ML_ERROR(_general_1.ME.ME_RANGE, 'bessel_j', printer);
        return NaN;
    }
    na = floor(alpha);
    if (alpha < 0) {
        return (((alpha - na === 0.5) ? 0 : bessel_j(x, -alpha) * cospi_1.cospi(alpha)) +
            ((alpha === na) ? 0 : besselY_1.bessel_y(x, -alpha) * sinpi_1.sinpi(alpha)));
    }
    else if (alpha > 1e7) {
        printer('besselJ(x, nu): nu=%d too large for bessel_j() algorithm', alpha);
        return NaN;
    }
    nb = 1 + trunc(na);
    alpha -= (nb - 1);
    var rc = Jbessel_1.J_bessel(x, alpha, nb);
    if (rc.ncalc !== nb) {
        if (rc.ncalc < 0)
            printer('bessel_j(%d): ncalc (=%d) != nb (=%d); alpha=%d. Arg. out of range?', x, rc.ncalc, rc.nb, alpha);
        else
            printer('bessel_j(%d,nu=%d): precision lost in result', x, alpha + nb - 1);
    }
    x = rc.x;
    return x;
}
exports.bessel_j = bessel_j;
//# sourceMappingURL=index.js.map