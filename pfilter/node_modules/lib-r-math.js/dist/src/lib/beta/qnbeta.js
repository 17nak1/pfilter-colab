"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var expm1_1 = require("../exp/expm1");
var pnbeta_1 = require("./pnbeta");
var ISNAN = Number.isNaN, R_FINITE = Number.isFinite, DBL_MIN = Number.MIN_VALUE, DBL_EPSILON = Number.EPSILON;
var fmin2 = Math.min;
var printer_qnbeta = debug('qnbeta');
function qnbeta(p, a, b, ncp, lower_tail, log_p) {
    var accu = 1e-15;
    var Eps = 1e-14;
    var ux;
    var lx;
    var nx;
    var pp;
    if (ISNAN(p) || ISNAN(a) || ISNAN(b) || ISNAN(ncp))
        return p + a + b + ncp;
    if (!R_FINITE(a))
        return _general_1.ML_ERR_return_NAN(printer_qnbeta);
    if (ncp < 0 || a <= 0 || b <= 0)
        return _general_1.ML_ERR_return_NAN(printer_qnbeta);
    var rc = _general_1.R_Q_P01_boundaries(lower_tail, log_p, p, 0, 1);
    if (rc !== undefined) {
        return rc;
    }
    p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
    if (p > 1 - DBL_EPSILON)
        return 1.0;
    pp = fmin2(1 - DBL_EPSILON, p * (1 + Eps));
    for (ux = 0.5; ux < 1 - DBL_EPSILON && pnbeta_1.pnbeta(ux, a, b, ncp, true, false) < pp; ux = 0.5 * (1 + ux))
        ;
    pp = p * (1 - Eps);
    for (lx = 0.5; lx > DBL_MIN && pnbeta_1.pnbeta(lx, a, b, ncp, true, false) > pp; lx *= 0.5)
        ;
    do {
        nx = 0.5 * (lx + ux);
        if (pnbeta_1.pnbeta(nx, a, b, ncp, true, false) > p)
            ux = nx;
        else
            lx = nx;
    } while ((ux - lx) / nx > accu);
    return 0.5 * (ux + lx);
}
exports.qnbeta = qnbeta;
//# sourceMappingURL=qnbeta.js.map