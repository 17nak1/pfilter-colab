"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var expm1_1 = require("../exp/expm1");
var lbeta_1 = require("../beta/lbeta");
var pbeta_1 = require("../beta/pbeta");
var expm1 = Math.expm1, log1p = Math.log1p, sqrt = Math.sqrt, fmin2 = Math.min, exp = Math.exp, fabs = Math.abs, log = Math.log, pow = Math.pow, fmax2 = Math.max;
var ISNAN = Number.isNaN, DBL_MIN = Number.MIN_VALUE, DBL_EPSILON = Number.EPSILON, ML_POSINF = Number.POSITIVE_INFINITY, ML_NEGINF = Number.NEGATIVE_INFINITY, R_FINITE = Number.isFinite, ML_NAN = Number.NaN;
var USE_LOG_X_CUTOFF = -5;
var n_NEWTON_FREE = 4;
var MLOGICAL_NA = -1;
var printer_qbeta = debug('qbeta');
function qbeta(pp, shape1, shape2, lower_tail, log_p) {
    var fa = Array.isArray(pp) ? pp : [pp];
    var result = fa.map(function (p) {
        if (ISNAN(shape1) || ISNAN(shape2) || ISNAN(p))
            return shape1 + shape2 + p;
        if (shape1 < 0 || shape2 < 0) {
            return _general_1.ML_ERR_return_NAN(printer_qbeta);
        }
        var qbet = [0, 0];
        qbeta_raw(p, shape1, shape2, lower_tail, log_p, MLOGICAL_NA, USE_LOG_X_CUTOFF, n_NEWTON_FREE, qbet);
        return qbet[0];
    });
    return result.length === 1 ? result[0] : result;
}
exports.qbeta = qbeta;
var DBL_very_MIN = DBL_MIN / 4;
var DBL_log_v_MIN = _general_1.M_LN2 * (_general_1.DBL_MIN_EXP - 2);
var DBL_1__eps = 1 - DBL_EPSILON;
var fpu = 3e-308;
var acu_min = 1e-300;
var p_lo = fpu;
var p_hi = 1 - 2.22e-16;
var const1 = 2.30753;
var const2 = 0.27061;
var const3 = 0.99229;
var const4 = 0.04481;
function return_q_0(give_log_q, qb) {
    if (give_log_q) {
        qb[0] = ML_NEGINF;
        qb[1] = 0;
    }
    else {
        qb[0] = 0;
        qb[1] = 1;
    }
    return;
}
function return_q_1(give_log_q, qb) {
    if (give_log_q) {
        qb[0] = 0;
        qb[1] = ML_NEGINF;
    }
    else {
        qb[0] = 1;
        qb[1] = 0;
    }
    return;
}
function return_q_half(give_log_q, qb) {
    if (give_log_q) {
        qb[0] = qb[1] = -_general_1.M_LN2;
    }
    else {
        qb[0] = qb[1] = 0.5;
    }
    return;
}
var printer_qbeta_raw = debug('qbeta_raw');
var R_ifDEBUG_printf = printer_qbeta_raw;
function qbeta_raw(alpha, p, q, lower_tail, log_p, swap_01, log_q_cut, n_N, qb) {
    var swap_choose = swap_01 === MLOGICAL_NA;
    var swap_tail;
    var log_;
    var give_log_q = log_q_cut === ML_POSINF;
    var use_log_x = give_log_q;
    var warned = false;
    var add_N_step = true;
    var i_pb;
    var i_inn;
    var a;
    var la;
    var logbeta;
    var g;
    var h;
    var pp;
    var p_;
    var qq;
    var r;
    var s;
    var t;
    var w;
    var y = -1;
    var u = 0;
    var xinbta = 0;
    var u_n = 0;
    if (alpha === _general_1.R_DT_0(lower_tail, log_p)) {
        return return_q_0(give_log_q, qb);
    }
    if (alpha === _general_1.R_DT_1(lower_tail, log_p)) {
        return return_q_1(give_log_q, qb);
    }
    if ((log_p && alpha > 0) || (!log_p && (alpha < 0 || alpha > 1))) {
        printer_qbeta_raw('qbeta(alpha=%d, %d, %d, .., log_p=%d): %s%s', alpha, p, q, log_p, 'alpha not in ', log_p ? '[-Inf, 0]' : '[0,1]');
        _general_1.ML_ERROR(_general_1.ME.ME_DOMAIN, '', printer_qbeta_raw);
        qb[0] = qb[1] = ML_NAN;
        return;
    }
    if (p === 0 || q === 0 || !R_FINITE(p) || !R_FINITE(q)) {
        printer_qbeta_raw('qbeta(%d, %d, %d, lower_t=%d, log_p=%d): (p,q)-boundary: trivial', alpha, p, q, lower_tail, log_p);
        if (p === 0 && q === 0) {
            if (alpha < _general_1.R_D_half(log_p)) {
                return_q_0(give_log_q, qb);
            }
            if (alpha > _general_1.R_D_half(log_p)) {
                return_q_1(give_log_q, qb);
            }
            return_q_half(give_log_q, qb);
        }
        else if (p === 0 || p / q === 0) {
            return_q_0;
        }
        else if (q === 0 || q / p === 0) {
            return_q_1;
        }
        return_q_half;
    }
    p_ = expm1_1.R_DT_qIv(lower_tail, log_p, alpha);
    logbeta = lbeta_1.lbeta(p, q);
    swap_tail = swap_choose ? p_ > 0.5 : swap_01;
    if (swap_tail) {
        a = expm1_1.R_DT_CIv(lower_tail, log_p, alpha);
        la = expm1_1.R_DT_Clog(lower_tail, log_p, alpha);
        pp = q;
        qq = p;
    }
    else {
        a = p_;
        la = expm1_1.R_DT_log(lower_tail, log_p, alpha);
        pp = p;
        qq = q;
    }
    var acu = fmax2(acu_min, pow(10, -13 - 2.5 / (pp * pp) - 0.5 / (a * a)));
    var tx = 0;
    var u0 = (la + log(pp) + logbeta) / pp;
    var log_eps_c = _general_1.M_LN2 * (1 - _general_1.DBL_MANT_DIG);
    r = pp * (1 - qq) / (pp + 1);
    t = 0.2;
    printer_qbeta_raw('qbeta(%d, %d, %d, lower_t=%d, log_p=%d):%s   swap_tail=%d, la=%d, u0=%d (bnd: %d (%d)) ', alpha, p, q, lower_tail, log_p, log_p && (p_ === 0 || p_ === 1) ? (p_ === 0 ? ' p_=0' : ' p_=1') : '', swap_tail, la, u0, (t * log_eps_c - log(fabs(pp * (1 - qq) * (2 - qq) / (2 * (pp + 2))))) / 2, t * log_eps_c - log(fabs(r)));
    var goto_L_Newton = false;
    var goto_L_return = false;
    var goto_L_converged = false;
    if (_general_1.M_LN2 * _general_1.DBL_MIN_EXP < u0 &&
        u0 < -0.01 &&
        u0 <
            (t * log_eps_c - log(fabs(pp * (1 - qq) * (2 - qq) / (2 * (pp + 2))))) / 2) {
        r = r * exp(u0);
        if (r > -1) {
            u = u0 - log1p(r) / pp;
            printer_qbeta_raw('u1-u0=%d --> choosing u = u1', u - u0);
        }
        else {
            u = u0;
            printer_qbeta_raw('cannot cheaply improve u0');
        }
        tx = xinbta = exp(u);
        use_log_x = true;
        goto_L_Newton = true;
    }
    if (!goto_L_Newton) {
        r = sqrt(-2 * la);
        y = r - (const1 + const2 * r) / (1 + (const3 + const4 * r) * r);
        if (pp > 1 && qq > 1) {
            r = (y * y - 3) / 6;
            s = 1 / (pp + pp - 1);
            t = 1 / (qq + qq - 1);
            h = 2 / (s + t);
            w = y * sqrt(h + r) / h - (t - s) * (r + 5.0 / 6.0 - 2.0 / (3 * h));
            printer_qbeta_raw('p,q > 1 => w=%d', w);
            if (w > 300) {
                t = w + w + log(qq) - log(pp);
                u =
                    t <= 18 ? -log1p(exp(t)) : -t - exp(-t);
                xinbta = exp(u);
            }
            else {
                xinbta = pp / (pp + qq * exp(w + w));
                u = -log1p(qq / pp * exp(w + w));
            }
        }
        else {
            r = qq + qq;
            t = 1 / (3 * sqrt(qq));
            t = r * _general_1.R_pow_di(1 + t * (-t + y), 3);
            s = 4 * pp + r - 2;
            R_ifDEBUG_printf('min(p,q) <= 1: t=%g', t);
            if (t === 0 || (t < 0 && s >= t)) {
                var l1ma = void 0;
                if (swap_tail)
                    l1ma = expm1_1.R_DT_log(lower_tail, log_p, alpha);
                else
                    l1ma = expm1_1.R_DT_Clog(lower_tail, log_p, alpha);
                R_ifDEBUG_printf(' t <= 0 : log1p(-a)=%.15g, better l1ma=%.15g\n', log1p(-a), l1ma);
                var xx = (l1ma + log(qq) + logbeta) / qq;
                if (xx <= 0) {
                    xinbta = -expm1(xx);
                    u = expm1_1.R_Log1_Exp(xx);
                }
                else {
                    R_ifDEBUG_printf(' xx=%g > 0: xinbta:= 1-e^xx < 0\n', xx);
                    xinbta = 0;
                    u = ML_NEGINF;
                }
            }
            else {
                t = s / t;
                R_ifDEBUG_printf(' t > 0 or s < t < 0:  new t = %g ( > 1 ?)\n', t);
                if (t <= 1) {
                    u = (la + log(pp) + logbeta) / pp;
                    xinbta = exp(u);
                }
                else {
                    xinbta = 1 - 2 / (t + 1);
                    u = log1p(-2 / (t + 1));
                }
            }
        }
        if (swap_choose &&
            ((swap_tail && u >= -exp(log_q_cut)) ||
                (!swap_tail && u >= -exp(4 * log_q_cut) && pp / qq < 1000))) {
            swap_tail = !swap_tail;
            R_ifDEBUG_printf(' u = %g (e^u = xinbta = %.16g) ==> ', u, xinbta);
            if (swap_tail) {
                a = expm1_1.R_DT_CIv(lower_tail, log_p, alpha);
                la = expm1_1.R_DT_Clog(lower_tail, log_p, alpha);
                pp = q;
                qq = p;
            }
            else {
                a = p_;
                la = expm1_1.R_DT_log(lower_tail, log_p, alpha);
                pp = p;
                qq = q;
            }
            R_ifDEBUG_printf('"%s\'; la = %g\n', swap_tail ? 'swap now' : 'swap back', la);
            u = expm1_1.R_Log1_Exp(u);
            xinbta = exp(u);
        }
        if (!use_log_x)
            use_log_x = u < log_q_cut;
        var bad_u = !R_FINITE(u);
        var bad_init = bad_u || xinbta > p_hi;
        R_ifDEBUG_printf(' -> u = %g, e^u = xinbta = %.16g, (Newton acu=%g%s)\n', u, xinbta, acu, bad_u ? ', ** bad u **' : use_log_x ? ', on u = log(x) scale' : '');
        u_n = 1;
        tx = xinbta;
        if (bad_u || u < log_q_cut) {
            w = pbeta_1.pbeta_raw(DBL_very_MIN, pp, qq, true, log_p);
            if (w > (log_p ? la : a)) {
                R_ifDEBUG_printf(' quantile is left of smallest positive number; "convergence"\n');
                if (log_p || fabs(w - a) < fabs(0 - a)) {
                    tx = DBL_very_MIN;
                    u_n = DBL_log_v_MIN;
                }
                else {
                    tx = 0;
                    u_n = ML_NEGINF;
                }
                use_log_x = log_p;
                add_N_step = false;
                goto_L_return = true;
            }
            else {
                R_ifDEBUG_printf(' pbeta(smallest pos.) = %g <= %g  --> continuing\n', w, log_p ? la : a);
                if (u < DBL_log_v_MIN) {
                    u = DBL_log_v_MIN;
                    xinbta = DBL_very_MIN;
                }
            }
        }
        if (bad_init && !(use_log_x && tx > 0)) {
            if (u === ML_NEGINF) {
                R_ifDEBUG_printf('  u = -Inf;');
                u = _general_1.M_LN2 * _general_1.DBL_MIN_EXP;
                xinbta = DBL_MIN;
            }
            else {
                R_ifDEBUG_printf(' bad_init: u=%g, xinbta=%g;', u, xinbta);
                xinbta =
                    xinbta > 1.1
                        ? 0.5
                        : xinbta < p_lo ? exp(u) : p_hi;
                if (bad_u)
                    u = log(xinbta);
            }
            R_ifDEBUG_printf(' -> (partly)new u=%g, xinbta=%g\n', u, xinbta);
        }
    }
    if (!goto_L_return) {
        r = 1 - pp;
        t = 1 - qq;
        var wprev = 0;
        var prev = 1;
        var adj = 1;
        if (use_log_x) {
            for (i_pb = 0; i_pb < 1000; i_pb++) {
                y = pbeta_1.pbeta_raw(xinbta, pp, qq, true, true);
                w =
                    y === ML_NEGINF
                        ? 0
                        : (y - la) * exp(y - u + logbeta + r * u + t * expm1_1.R_Log1_Exp(u));
                if (!R_FINITE(w))
                    break;
                if (i_pb >= n_N && w * wprev <= 0)
                    prev = fmax2(fabs(adj), fpu);
                R_ifDEBUG_printf('N(i=%2d): u=%#20.16g, pb(e^u)=%#12.6g, w=%#15.9g, %s prev=%11g,', i_pb, u, y, w, w * wprev <= 0 ? 'new' : 'old', prev);
                g = 1;
                for (i_inn = 0; i_inn < 1000; i_inn++) {
                    adj = g * w;
                    if (i_pb < n_N || fabs(adj) < prev) {
                        u_n = u - adj;
                        if (u_n <= 0) {
                            if (prev <= acu || fabs(w) <= acu) {
                                R_ifDEBUG_printf(' it{in}=%d, -adj=%g, %s <= acu  ==> convergence\n', i_inn, -adj, prev <= acu ? 'prev' : '|w|');
                                goto_L_converged = true;
                                break;
                            }
                            break;
                        }
                    }
                    g /= 3;
                }
                if (goto_L_converged) {
                    break;
                }
                var D = fmin2(fabs(adj), fabs(u_n - u));
                R_ifDEBUG_printf(' it{in}=%d, delta(u)=%9.3g, D/|.|=%.3g\n', i_inn, u_n - u, D / fabs(u_n + u));
                if (D <= 4e-16 * fabs(u_n + u)) {
                    goto_L_converged = true;
                    break;
                }
                u = u_n;
                xinbta = exp(u);
                wprev = w;
            }
        }
        else {
            for (i_pb = 0; i_pb < 1000; i_pb++) {
                y = pbeta_1.pbeta_raw(xinbta, pp, qq, true, log_p);
                if (!R_FINITE(y) && !(log_p && y === ML_NEGINF)) {
                    _general_1.ML_ERROR(_general_1.ME.ME_DOMAIN, '', printer_qbeta_raw);
                    qb[0] = qb[1] = ML_NAN;
                    return;
                }
                w = log_p
                    ? (y - la) * exp(y + logbeta + r * log(xinbta) + t * log1p(-xinbta))
                    : (y - a) * exp(logbeta + r * log(xinbta) + t * log1p(-xinbta));
                if (i_pb >= n_N && w * wprev <= 0)
                    prev = fmax2(fabs(adj), fpu);
                R_ifDEBUG_printf('N(i=%2d): x0=%d, pb(x0)=%d, w=%d, %s prev=%d,', i_pb, xinbta, y, w, w * wprev <= 0 ? 'new' : 'old', prev);
                g = 1;
                for (i_inn = 0; i_inn < 1000; i_inn++) {
                    adj = g * w;
                    if (i_pb < n_N || fabs(adj) < prev) {
                        tx = xinbta - adj;
                        if (0 <= tx && tx <= 1) {
                            if (prev <= acu || fabs(w) <= acu) {
                                R_ifDEBUG_printf(' it{in}=%d, delta(x)=%g, %s <= acu  ==> convergence\n', i_inn, -adj, prev <= acu ? 'prev' : '|w|');
                                goto_L_converged = true;
                                break;
                            }
                            if (tx !== 0 && tx !== 1)
                                break;
                        }
                    }
                    g /= 3;
                }
                if (goto_L_converged) {
                    break;
                }
                R_ifDEBUG_printf(' it{in}=%d, delta(x)=%g\n', i_inn, tx - xinbta);
                if (fabs(tx - xinbta) <= 4e-16 * (tx + xinbta)) {
                    goto_L_converged = true;
                    break;
                }
                xinbta = tx;
                if (tx === 0)
                    break;
                wprev = w;
            }
        }
        if (!goto_L_converged) {
            warned = true;
            _general_1.ML_ERROR(_general_1.ME.ME_PRECISION, 'qbeta', printer_qbeta_raw);
        }
        log_ = log_p || use_log_x;
        R_ifDEBUG_printf(' %s: Final delta(y) = %g%s\n', warned ? '_NO_ convergence' : 'converged', y - (log_ ? la : a), log_ ? ' (log_)' : '');
        if ((log_ && y === ML_NEGINF) || (!log_ && y === 0)) {
            w = pbeta_1.pbeta_raw(DBL_very_MIN, pp, qq, true, log_);
            if (log_ || fabs(w - a) <= fabs(y - a)) {
                tx = DBL_very_MIN;
                u_n = DBL_log_v_MIN;
            }
            add_N_step = false;
        }
        else if (!warned && (log_ ? fabs(y - la) > 3 : fabs(y - a) > 1e-4)) {
            if (!(log_ &&
                y === ML_NEGINF &&
                pbeta_1.pbeta_raw(DBL_1__eps, pp, qq, true, true) >
                    la + 2))
                printer_qbeta_raw('qbeta(a, *) =: x0 with |pbeta(x0,* %s) - alpha| = %d is not accurate', log_ ? ', log_' : '', fabs(y - (log_ ? la : a)));
        }
    }
    if (give_log_q) {
        if (!use_log_x)
            printer_qbeta_raw('qbeta() L_return, u_n=%d;  give_log_q=TRUE but use_log_x=FALSE -- please report!', u_n);
        var r_1 = expm1_1.R_Log1_Exp(u_n);
        if (swap_tail) {
            qb[0] = r_1;
            qb[1] = u_n;
        }
        else {
            qb[0] = u_n;
            qb[1] = r_1;
        }
    }
    else {
        if (use_log_x) {
            if (add_N_step) {
                xinbta = exp(u_n);
                y = pbeta_1.pbeta_raw(xinbta, pp, qq, true, log_p);
                w = log_p
                    ? (y - la) * exp(y + logbeta + r * log(xinbta) + t * log1p(-xinbta))
                    : (y - a) * exp(logbeta + r * log(xinbta) + t * log1p(-xinbta));
                tx = xinbta - w;
                R_ifDEBUG_printf('Final Newton correction(non-log scale): xinbta=%.16g, y=%g, w=%g. => new tx=%.16g\n', xinbta, y, w, tx);
            }
            else {
                if (swap_tail) {
                    qb[0] = -expm1(u_n);
                    qb[1] = exp(u_n);
                }
                else {
                    qb[0] = exp(u_n);
                    qb[1] = -expm1(u_n);
                }
                return;
            }
        }
        if (swap_tail) {
            qb[0] = 1 - tx;
            qb[1] = tx;
        }
        else {
            qb[0] = tx;
            qb[1] = 1 - tx;
        }
    }
    return;
}
exports.qbeta_raw = qbeta_raw;
//# sourceMappingURL=qbeta.js.map