'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var pbeta_1 = require("../beta/pbeta");
var _general_1 = require("../common/_general");
var lgammafn_sign_1 = require("../gamma/lgammafn_sign");
var pnorm_1 = require("../normal/pnorm");
var pt_1 = require("./pt");
var R_FINITE = Number.isFinite, DBL_EPSILON = Number.EPSILON;
var sqrt = Math.sqrt, exp = Math.exp, pow = Math.pow, log = Math.log, expm1 = Math.expm1, fabs = Math.abs, fmin2 = Math.min;
var printer_pnt = debug('pnt');
var DBL_MIN_EXP = -1021;
var M_LN2 = 0.693147180559945309417;
function pnt(_t, df, ncp, lower_tail, log_p) {
    if (lower_tail === void 0) { lower_tail = true; }
    if (log_p === void 0) { log_p = false; }
    var errbd;
    var rxb;
    var x;
    var geven;
    var godd;
    var p;
    var q;
    var s;
    var tnc = 0;
    var xeven;
    var xodd;
    var itrmax = 1000;
    var errmax = 1e-12;
    if (df <= 0.0) {
        return _general_1.ML_ERR_return_NAN(printer_pnt);
    }
    if (ncp === 0.0) {
        return pt_1.pt(_t, df, lower_tail, log_p);
    }
    if (!R_FINITE(_t)) {
        return _t < 0 ? _general_1.R_DT_0(lower_tail, log_p) : _general_1.R_DT_1(lower_tail, log_p);
    }
    var negdel = _t < 0;
    var tt = fabs(_t);
    var del = _t >= 0 ? ncp : -ncp;
    if (_t < 0 && ncp > 40 && (!log_p || !lower_tail)) {
        printer_pnt('if x <=0 and solution for edge ncp > 40');
        return _general_1.R_DT_0(lower_tail, log_p);
    }
    if (df > 4e5 || del * del > 2 * M_LN2 * -DBL_MIN_EXP) {
        printer_pnt('Abramowitz & Stegun 26.7.10 ncp:%d, del:%d, ncp2:%d, del2:%d, D:%d', ncp, del, ncp * ncp, del * del, 2 * M_LN2 * -DBL_MIN_EXP);
        var _s = 1 / (4 * df);
        return pnorm_1.pnorm5(tt * (1 - _s), del, sqrt(1 + tt * tt * 2 * _s), lower_tail !== negdel, log_p);
    }
    x = _t * _t;
    rxb = df / (x + df);
    x = x / (x + df);
    printer_pnt('pnt(t=%d, df=%d, ncp=%d, rxb=%d) ==> x= %d', _t, df, ncp, rxb, x);
    if (x > 0) {
        printer_pnt('x > 0 branch');
        var lambda = del * del;
        p = 0.5 * exp(-0.5 * lambda);
        printer_pnt('p=%d', p);
        if (p === 0) {
            printer_pnt('p=%d, underflow protection', p);
            _general_1.ML_ERROR(_general_1.ME.ME_UNDERFLOW, 'pnt', printer_pnt);
            _general_1.ML_ERROR(_general_1.ME.ME_RANGE, 'pnt', printer_pnt);
            return _general_1.R_DT_0(lower_tail, log_p);
        }
        printer_pnt('it  1e5*(godd,   geven)|          p           q           s' +
            '        pnt(*)     errbd');
        q = _general_1.M_SQRT_2dPI * p * del;
        s = 0.5 - p;
        if (s < 1e-7)
            s = -0.5 * expm1(-0.5 * lambda);
        var a = 0.5;
        var b = 0.5 * df;
        rxb = pow(rxb, b);
        var albeta = _general_1.M_LN_SQRT_PI + lgammafn_sign_1.lgammafn_sign(b) - lgammafn_sign_1.lgammafn_sign(0.5 + b);
        xodd = pbeta_1.pbeta(x, a, b, true, false);
        printer_pnt('return from pbeta:%d', xodd);
        godd = 2 * rxb * exp(a * log(x) - albeta);
        tnc = b * x;
        xeven = tnc < DBL_EPSILON ? tnc : 1 - rxb;
        geven = tnc * rxb;
        tnc = p * xodd + q * xeven;
        var gotoFinis = false;
        for (var it_1 = 1; it_1 <= itrmax; it_1++) {
            a += 1;
            xodd -= godd;
            xeven -= geven;
            godd *= x * (a + b - 1) / a;
            geven *= x * (a + b - 0.5) / (a + 0.5);
            p *= lambda / (2 * it_1);
            q *= lambda / (2 * it_1 + 1);
            tnc += p * xodd + q * xeven;
            s -= p;
            if (s < -1e-10) {
                _general_1.ML_ERROR(_general_1.ME.ME_PRECISION, 'pnt', printer_pnt);
                printer_pnt('goto:true, s = %d < 0 !!! ---> non-convergence!!', s);
                gotoFinis = true;
                break;
            }
            if (s <= 0) {
                printer_pnt('goto:true, s:%d < 0 && it:%d>1', s, it_1);
                gotoFinis = true;
                break;
            }
            errbd = 2 * s * (xodd - godd);
            printer_pnt('%d %d %d|%d %d %d %d %d', it_1, 1e5 * godd, 1e5 * geven, p, q, s, tnc, errbd);
            if (fabs(errbd) < errmax) {
                printer_pnt('goto:true, errbd:%d < errmax:%d', errbd, errmax);
                gotoFinis = true;
                break;
            }
            gotoFinis = false;
        }
        if (!gotoFinis) {
            _general_1.ML_ERROR(_general_1.ME.ME_NOCONV, 'pnt', printer_pnt);
        }
    }
    tnc += pnorm_1.pnorm5(-del, 0, 1, true, false);
    lower_tail = lower_tail !== negdel;
    if (tnc > 1 - 1e-10 && lower_tail) {
        _general_1.ML_ERROR(_general_1.ME.ME_PRECISION, 'pnt{final}', printer_pnt);
    }
    var rc = _general_1.R_DT_val(lower_tail, log_p, fmin2(tnc, 1));
    printer_pnt('rc:%d, tnc:%d, log_p:%s, lower_tail:%s', rc, tnc, log_p, lower_tail);
    return rc;
}
exports.pnt = pnt;
//# sourceMappingURL=pnt.js.map