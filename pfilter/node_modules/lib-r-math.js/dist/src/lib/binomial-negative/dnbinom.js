"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var dbinom_1 = require("../binomial/dbinom");
var lgammafn_sign_1 = require("../gamma/lgammafn_sign");
var printer = debug('dnbinom');
var log = Math.log, R_forceint = Math.round, log1p = Math.log1p;
var R_FINITE = Number.isFinite, ISNAN = Number.isNaN;
function dnbinom(xx, size, prob, give_log) {
    var fx = Array.isArray(xx) ? xx : [xx];
    var result = fx.map(function (x) {
        var ans;
        var p;
        if (ISNAN(x) || ISNAN(size) || ISNAN(prob)) {
            return x + size + prob;
        }
        if (prob <= 0 || prob > 1 || size < 0) {
            return _general_1.ML_ERR_return_NAN(printer);
        }
        var rc = _general_1.R_D_nonint_check(give_log, x, printer);
        if (rc !== undefined) {
            return rc;
        }
        if (x < 0 || !R_FINITE(x)) {
            return _general_1.R_D__0(give_log);
        }
        if (x === 0 && size === 0) {
            return _general_1.R_D__1(give_log);
        }
        x = R_forceint(x);
        ans = dbinom_1.dbinom_raw(size, x + size, prob, 1 - prob, give_log);
        p = size / (size + x);
        return give_log ? log(p) + ans : p * ans;
    });
    return result.length === 1 ? result[0] : result;
}
exports.dnbinom = dnbinom;
var printer_dnbinom_mu = debug('dnbinom_mu');
function dnbinom_mu(xx, size, mu, give_log) {
    var fx = Array.isArray(xx) ? xx : [xx];
    var result = fx.map(function (x) {
        var ans;
        var p;
        if (ISNAN(x) || ISNAN(size) || ISNAN(mu)) {
            return x + size + mu;
        }
        if (mu < 0 || size < 0) {
            return _general_1.ML_ERR_return_NAN(printer_dnbinom_mu);
        }
        var rc = _general_1.R_D_nonint_check(give_log, x, printer_dnbinom_mu);
        if (rc !== undefined) {
            return rc;
        }
        if (x < 0 || !R_FINITE(x)) {
            return _general_1.R_D__0(give_log);
        }
        if (x === 0 && size === 0) {
            return _general_1.R_D__1(give_log);
        }
        x = R_forceint(x);
        if (x === 0) {
            var llogx = void 0;
            if (size < mu) {
                llogx = log(size / (size + mu));
            }
            else {
                llogx = log1p(-mu / (size + mu));
            }
            return _general_1.R_D_exp(give_log, size * llogx);
        }
        if (x < 1e-10 * size) {
            p = size < mu ? log(size / (1 + size / mu)) : log(mu / (1 + mu / size));
            return _general_1.R_D_exp(give_log, x * p - mu - lgammafn_sign_1.lgammafn_sign(x + 1) + log1p(x * (x - 1) / (2 * size)));
        }
        ans = dbinom_1.dbinom_raw(size, x + size, size / (size + mu), mu / (size + mu), give_log);
        p = size / (size + x);
        return give_log ? log(p) + ans : p * ans;
    });
    return result.length === 0 ? result[0] : result;
}
exports.dnbinom_mu = dnbinom_mu;
//# sourceMappingURL=dnbinom.js.map