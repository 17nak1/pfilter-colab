"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var R_FINITE = Number.isFinite;
var fabs = Math.abs;
var rbinom_1 = require("../binomial/rbinom");
var r_func_1 = require("../r-func");
var printer_rmultinom = debug('rmultinom');
function rmultinom(n, size, prob, rng) {
    return r_func_1.randomGenHelper(n, rmultinomOne, size, prob, rng);
}
exports.rmultinom = rmultinom;
function rmultinomOne(size, prob, rng) {
    var rN = [];
    var p = Array.from(r_func_1.flatten(prob));
    var K = p.length;
    if (p.length === 0) {
        printer_rmultinom('list of probabilities cannot be empty');
        return rN;
    }
    if (size < 0) {
        printer_rmultinom('Illegal Argument:size is negative');
        rN.splice(0);
        return rN;
    }
    if (p.find(function (pp) { return !R_FINITE(pp) || pp < 0; })) {
        printer_rmultinom('some propbabilities are invalid or negative numbers');
        rN.splice(0);
        return rN;
    }
    rN.splice.apply(rN, __spread([0, rN.length], new Array(K).fill(0)));
    if (size === 0) {
        return rN;
    }
    var _size = size;
    var p_tot = r_func_1.sum(p);
    printer_rmultinom('%o', { p: p, p_tot: p_tot, _size: _size, K: K, rN: rN });
    for (var k = 0; k < K - 1; k++) {
        if (fabs(p_tot) < Number.EPSILON) {
            rN[k] = _size;
            _size = 0;
            p_tot = 0;
            continue;
        }
        var pp = p[k] / p_tot;
        if (pp === 0) {
            rN[k] = 0;
            continue;
        }
        if (_size === 0) {
            rN[k] = 0;
            continue;
        }
        rN[k] = pp < 1 ? rbinom_1.rbinomOne(_size, pp, rng) : _size;
        _size -= rN[k];
        p_tot -= p[k];
        printer_rmultinom('%o', { p_tot: p_tot, _size: _size, k: k, rN: rN });
    }
    rN[K - 1] = _size;
    return rN;
}
exports.rmultinomOne = rmultinomOne;
//# sourceMappingURL=rmultinom.js.map