'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var expm1_1 = require("../exp/expm1");
var cwilcox_1 = require("./cwilcox");
var WilcoxonCache_1 = require("./WilcoxonCache");
var choose_1 = require("../common/choose");
var R_forceint = Math.round, trunc = Math.trunc;
var ISNAN = Number.isNaN, R_FINITE = Number.isFinite, DBL_EPSILON = Number.EPSILON;
var printer_qwilcox = debug('qwilcox');
function qwilcox(x, m, n, lowerTail, logP) {
    if (lowerTail === void 0) { lowerTail = true; }
    if (logP === void 0) { logP = false; }
    m = R_forceint(m);
    n = R_forceint(n);
    var w = new WilcoxonCache_1.WilcoxonCache();
    if (ISNAN(x) || ISNAN(m) || ISNAN(n))
        return x + m + n;
    if (!R_FINITE(x) || !R_FINITE(m) || !R_FINITE(n))
        return _general_1.ML_ERR_return_NAN(printer_qwilcox);
    _general_1.R_Q_P01_check(logP, x);
    if (m <= 0 || n <= 0)
        return _general_1.ML_ERR_return_NAN(printer_qwilcox);
    if (x === _general_1.R_DT_0(lowerTail, logP))
        return 0;
    if (x === _general_1.R_DT_1(lowerTail, logP))
        return m * n;
    if (logP || !lowerTail)
        x = expm1_1.R_DT_qIv(lowerTail, logP, x);
    var c = choose_1.internal_choose(m + n, n);
    var p = 0;
    var q = 0;
    if (x <= 0.5) {
        x = x - 10 * DBL_EPSILON;
        while (true) {
            p += cwilcox_1.cwilcox(q, m, n, w) / c;
            if (p >= x)
                break;
            q++;
        }
    }
    else {
        x = 1 - x + 10 * DBL_EPSILON;
        while (true) {
            p += cwilcox_1.cwilcox(q, m, n, w) / c;
            if (p > x) {
                q = trunc(m * n - q);
                break;
            }
            q++;
        }
    }
    return q;
}
exports.qwilcox = qwilcox;
//# sourceMappingURL=qwilcox.js.map