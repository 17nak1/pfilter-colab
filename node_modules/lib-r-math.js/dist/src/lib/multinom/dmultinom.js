"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gamma_1 = require("../gamma");
var r_func_1 = require("../r-func");
var isFinite = Number.isFinite;
var lgamma = gamma_1.default.lgamma;
function dmultinom(o) {
    o.asLog = !!o.asLog;
    var x = Array.from(r_func_1.flatten(o.x)).filter(function (f) { return !!f; });
    var prob = r_func_1.flatten(o.prob);
    var badProb = !!prob.find(function (f) { return !isFinite(f) || f < 0; });
    var s = r_func_1.sum(prob);
    if (badProb || s === 0) {
        throw new Error('probabilities must be finite, non-negative and not all 0');
    }
    prob = prob.map(function (v) { return v / s; });
    x = x.map(Math.round);
    if (x.find(function (v) { return v < 0; })) {
        throw new Error('probabilities must be finite, non-negative and not all 0');
    }
    var N = r_func_1.sum(x);
    var size = !!o.size ? o.size : N;
    if (size !== N) {
        throw new Error("size:" + size + " != sum(x):" + N + ", i.e. one is wrong");
    }
    var i0 = prob.map(function (p) { return p === 0; });
    if (i0.includes(true)) {
        if (i0.find(function (_v, i) { return x[i] !== 0; })) {
            return o.asLog ? -Infinity : 0;
        }
        x = x.filter(function (_v, i) { return i0[i]; });
        prob = prob.filter(function (_v, i) { return i0[i]; });
    }
    var errMsg = [];
    if (prob.length <= 1) {
        errMsg.push("number of propabilities need to be at least 2, it is:" + prob.length);
    }
    if (x.length <= 1) {
        errMsg.push("number of quantiles need to be at least 2, it is :" + x.length);
    }
    if (x.length !== prob.length) {
        errMsg.push("number of effective quantiles:" + x.length + " is not equal to number of effective probabilities:" + prob.length + ".");
    }
    if (errMsg.length) {
        throw new Error(errMsg.join('\n'));
    }
    var s1 = x.map(function (v) { return v + 1; }).map(function (v) { return lgamma(v); });
    var s2 = prob.map(Math.log);
    var s3 = x.map(function (v, i) { return v * s2[i] - s1[i]; });
    var r = lgamma(size + 1) + r_func_1.sum(s3);
    return o.asLog ? r : Math.exp(r);
}
exports.dmultinom = dmultinom;
//# sourceMappingURL=dmultinom.js.map