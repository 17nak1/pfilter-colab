"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var gamma_fn_1 = require("../gamma/gamma_fn");
var lgammacor_1 = require("../gamma/lgammacor");
var lgammafn_sign_1 = require("../gamma/lgammafn_sign");
var log = Math.log, log1p = Math.log1p;
var ISNAN = Number.isNaN, R_FINITE = Number.isFinite, ML_POSINF = Number.POSITIVE_INFINITY, ML_NEGINF = Number.NEGATIVE_INFINITY;
var printer = debug('lbeta');
function lbeta(a, b) {
    var corr;
    var p;
    var q;
    if (ISNAN(a) || ISNAN(b))
        return a + b;
    p = q = a;
    if (b < p)
        p = b;
    if (b > q)
        q = b;
    if (p < 0)
        return _general_1.ML_ERR_return_NAN(printer);
    else if (p === 0) {
        return ML_POSINF;
    }
    else if (!R_FINITE(q)) {
        return ML_NEGINF;
    }
    if (p >= 10) {
        corr = lgammacor_1.lgammacor(p) + lgammacor_1.lgammacor(q) - lgammacor_1.lgammacor(p + q);
        return (log(q) * -0.5 +
            _general_1.M_LN_SQRT_2PI +
            corr +
            (p - 0.5) * log(p / (p + q)) +
            q * log1p(-p / (p + q)));
    }
    else if (q >= 10) {
        corr = lgammacor_1.lgammacor(q) - lgammacor_1.lgammacor(p + q);
        return (lgammafn_sign_1.lgammafn_sign(p) +
            corr +
            p -
            p * log(p + q) +
            (q - 0.5) * log1p(-p / (p + q)));
    }
    else {
        return log(gamma_fn_1.gammafn(p) * (gamma_fn_1.gammafn(q) / gamma_fn_1.gammafn(p + q)));
    }
}
exports.lbeta = lbeta;
//# sourceMappingURL=lbeta.js.map