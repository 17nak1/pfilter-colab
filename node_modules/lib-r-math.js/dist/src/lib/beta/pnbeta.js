"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var lgammafn_sign_1 = require("../gamma/lgammafn_sign");
var toms708_1 = require("../common/toms708");
var log1p = Math.log1p, floor = Math.floor, fmax2 = Math.max, sqrt = Math.sqrt, log = Math.log, exp = Math.exp;
var ISNAN = Number.isNaN;
var printer = debug('pnbeta_raw');
function pnbeta_raw(x, o_x, a, b, ncp) {
    var errmax = 1.0e-9;
    var itrmax = 10000;
    var a0;
    var lbeta;
    var c;
    var errbd;
    var x0;
    var temp = new toms708_1.NumberW(0);
    var tmp_c = new toms708_1.NumberW(0);
    var ierr = new toms708_1.NumberW(0);
    var ans;
    var ax;
    var gx;
    var q;
    var sumq;
    if (ncp < 0 || a <= 0 || b <= 0) {
        return _general_1.ML_ERR_return_NAN(printer);
    }
    if (x < 0 || o_x > 1 || (x === 0 && o_x === 1))
        return 0;
    if (x > 1 || o_x < 0 || (x === 1 && o_x === 0))
        return 1;
    c = ncp / 2;
    x0 = floor(fmax2(c - 7 * sqrt(c), 0));
    a0 = a + x0;
    lbeta = lgammafn_sign_1.lgammafn_sign(a0) + lgammafn_sign_1.lgammafn_sign(b) - lgammafn_sign_1.lgammafn_sign(a0 + b);
    toms708_1.Toms708.bratio(a0, b, x, o_x, temp, tmp_c, ierr);
    gx = exp(a0 * log(x) + b * (x < 0.5 ? log1p(-x) : log(o_x)) - lbeta - log(a0));
    if (a0 > a)
        q = exp(-c + x0 * log(c) - lgammafn_sign_1.lgammafn_sign(x0 + 1));
    else
        q = exp(-c);
    sumq = 1 - q;
    ans = ax = q * temp.val;
    var j = floor(x0);
    do {
        j++;
        temp.val -= gx;
        gx *= x * (a + b + j - 1) / (a + j);
        q *= c / j;
        sumq -= q;
        ax = temp.val * q;
        ans += ax;
        errbd = (temp.val - gx) * sumq;
    } while (errbd > errmax && j < itrmax + x0);
    if (errbd > errmax)
        _general_1.ML_ERROR(_general_1.ME.ME_PRECISION, 'pnbeta', printer);
    if (j >= itrmax + x0)
        _general_1.ML_ERROR(_general_1.ME.ME_NOCONV, 'pnbeta', printer);
    return ans;
}
var printer_pnbeta2 = debug('pnbeta2');
function pnbeta2(x, o_x, a, b, ncp, lower_tail, log_p) {
    var ans = pnbeta_raw(x, o_x, a, b, ncp);
    if (lower_tail) {
        return log_p ? log(ans) : ans;
    }
    else {
        if (ans > 1 - 1e-10)
            _general_1.ML_ERROR(_general_1.ME.ME_PRECISION, 'pnbeta', printer_pnbeta2);
        if (ans > 1.0)
            ans = 1.0;
        return log_p ? log1p(-ans) : 1 - ans;
    }
}
exports.pnbeta2 = pnbeta2;
function pnbeta(x, a, b, ncp, lower_tail, log_p) {
    if (ISNAN(x) || ISNAN(a) || ISNAN(b) || ISNAN(ncp))
        return x + a + b + ncp;
    var rc = _general_1.R_P_bounds_01(lower_tail, log_p, x, 0, 1);
    if (rc !== undefined) {
        return rc;
    }
    return pnbeta2(x, 1 - x, a, b, ncp, lower_tail, log_p);
}
exports.pnbeta = pnbeta;
//# sourceMappingURL=pnbeta.js.map