"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var fmax2 = Math.max, fmin2 = Math.min, floor = Math.floor, sqrt = Math.sqrt;
var ISNAN = Number.isNaN, R_FINITE = Number.isFinite, DBL_EPSILON = Number.EPSILON;
var toms708_1 = require("../common/toms708");
var expm1_1 = require("../exp/expm1");
var qnorm_1 = require("../normal/qnorm");
var pbinom_1 = require("./pbinom");
var printer_do_search = debug('do_search');
function do_search(y, z, p, n, pr, incr) {
    if (z.val >= p) {
        printer_do_search('new z=%o >= p = %d  --> search to left (y--) ..', z, p);
        while (true) {
            var newz = void 0;
            if (y === 0 ||
                (newz = pbinom_1.pbinom(y - incr, n, pr, true, false)) < p)
                return y;
            y = fmax2(0, y - incr);
            z.val = newz;
        }
    }
    else {
        printer_do_search('new z=%d < p = %d  --> search to right (y++) ..', z.val, p);
        while (true) {
            y = fmin2(y + incr, n);
            if (y === n ||
                (z.val = pbinom_1.pbinom(y, n, pr, true, false)) >= p)
                return y;
        }
    }
}
var printer_qbinom = debug('_qbinom');
function qbinom(p, size, pr, lower_tail, log_p) {
    var q;
    var mu;
    var sigma;
    var gamma;
    var z = new toms708_1.NumberW(0);
    var y;
    if (ISNAN(p) || ISNAN(size) || ISNAN(pr))
        return NaN;
    if (!R_FINITE(size) || !R_FINITE(pr)) {
        return _general_1.ML_ERR_return_NAN(printer_qbinom);
    }
    if (!R_FINITE(p) && !log_p) {
        return _general_1.ML_ERR_return_NAN(printer_qbinom);
    }
    if (!Number.isInteger(size)) {
        return _general_1.ML_ERR_return_NAN(printer_qbinom);
    }
    if (pr < 0 || pr > 1 || size < 0) {
        return _general_1.ML_ERR_return_NAN(printer_qbinom);
    }
    var rc = _general_1.R_Q_P01_boundaries(lower_tail, log_p, p, 0, size);
    if (rc !== undefined) {
        return rc;
    }
    if (pr === 0 || size === 0)
        return 0;
    q = 1 - pr;
    if (q === 0)
        return size;
    mu = size * pr;
    sigma = sqrt(size * pr * q);
    gamma = (q - pr) / sigma;
    printer_qbinom('qbinom(p=%d, n=%d, pr=%d, l.t.=%s, log=%s): sigm=%d, gam=%d', p, size, pr, lower_tail, log_p, sigma, gamma);
    if (!lower_tail || log_p) {
        p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
        if (p === 0)
            return 0;
        if (p === 1)
            return size;
    }
    if (Math.abs(p - 1) < DBL_EPSILON) {
        return size;
    }
    z.val = qnorm_1.qnorm(p, 0, 1, true, false);
    y = floor(mu + sigma * (z.val + gamma * (z.val * z.val - 1) / 6) + 0.5);
    if (y > size) {
        y = size;
    }
    printer_qbinom('  new (p,1-p)=(%d,%d), z=qnorm(..)=%d, y=%d, size=%d', p, 1 - p, z.val, y, size);
    z.val = pbinom_1.pbinom(y, size, pr, true, false);
    p *= 1 - 64 * DBL_EPSILON;
    if (size < 1e5) {
        return do_search(y, z, p, size, pr, 1);
    }
    var incr = floor(size * 0.001);
    var oldincr;
    do {
        console.log('loopdieloop');
        oldincr = incr;
        y = do_search(y, z, p, size, pr, incr);
        incr = fmax2(1, floor(incr / 100));
    } while (oldincr > 1 && incr > size * 1e-15);
    return y;
}
exports.qbinom = qbinom;
//# sourceMappingURL=qbinom.js.map