"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var expm1_1 = require("../exp/expm1");
var dnorm_1 = require("../normal/dnorm");
var pnorm_1 = require("../normal/pnorm");
var dpois_1 = require("../poisson/dpois");
var lgammafn_sign_1 = require("./lgammafn_sign");
var M_LN2 = Math.LN2, log1p = Math.log1p, expm1 = Math.expm1, sqrt = Math.sqrt, floor = Math.floor, pow = Math.pow, log = Math.log, exp = Math.exp, fmax2 = Math.max, fabs = Math.abs;
var ISNAN = Number.isNaN, DBL_MIN = Number.MIN_VALUE, DBL_EPSILON = Number.EPSILON, R_FINITE = Number.isFinite, ML_POSINF = Number.POSITIVE_INFINITY;
var isArray = Array.isArray;
var sqr = function (x) { return x * x; };
var scalefactor = sqr(sqr(sqr(4294967296.0)));
var M_cutoff = M_LN2 * _general_1.DBL_MAX_EXP / DBL_EPSILON;
function logcf(x, i, d, eps) {
    var c1 = 2 * d;
    var c2 = i + d;
    var c4 = c2 + d;
    var a1 = c2;
    var b1 = i * (c2 - i * x);
    var b2 = d * d * x;
    var a2 = c4 * c2 - b2;
    b2 = c4 * b1 - i * b2;
    while (fabs(a2 * b1 - a1 * b2) > fabs(eps * b1 * b2)) {
        var c3 = c2 * c2 * x;
        c2 += d;
        c4 += d;
        a1 = c4 * a2 - c3 * a1;
        b1 = c4 * b2 - c3 * b1;
        c3 = c1 * c1 * x;
        c1 += d;
        c4 += d;
        a2 = c4 * a1 - c3 * a2;
        b2 = c4 * b1 - c3 * b2;
        if (fabs(b2) > scalefactor) {
            a1 /= scalefactor;
            b1 /= scalefactor;
            a2 /= scalefactor;
            b2 /= scalefactor;
        }
        else if (fabs(b2) < 1 / scalefactor) {
            a1 *= scalefactor;
            b1 *= scalefactor;
            a2 *= scalefactor;
            b2 *= scalefactor;
        }
    }
    return a2 / b2;
}
function log1pmx(x) {
    var minLog1Value = -0.79149064;
    if (x > 1 || x < minLog1Value)
        return log1p(x) - x;
    else {
        var r = x / (2 + x);
        var y = r * r;
        if (fabs(x) < 1e-2) {
            var two = 2;
            return (r * ((((two / 9 * y + two / 7) * y + two / 5) * y + two / 3) * y - x));
        }
        else {
            var tol_logcf = 1e-14;
            return r * (2 * y * logcf(y, 3, 2, tol_logcf) - x);
        }
    }
}
function lgamma1p(a) {
    var eulers_const = 0.5772156649015328606065120900824024;
    var N = 40;
    var coeffs = [
        0.3224670334241132182362075833230126,
        0.6735230105319809513324605383715e-1,
        0.2058080842778454787900092413529198e-1,
        0.7385551028673985266273097291406834e-2,
        0.2890510330741523285752988298486755e-2,
        0.1192753911703260977113935692828109e-2,
        0.5096695247430424223356548135815582e-3,
        0.2231547584535793797614188036013401e-3,
        0.994575127818085337145958900319017e-4,
        0.4492623673813314170020750240635786e-4,
        0.2050721277567069155316650397830591e-4,
        0.9439488275268395903987425104415055e-5,
        0.4374866789907487804181793223952411e-5,
        0.2039215753801366236781900709670839e-5,
        0.9551412130407419832857179772951265e-6,
        0.4492469198764566043294290331193655e-6,
        0.2120718480555466586923135901077628e-6,
        0.1004322482396809960872083050053344e-6,
        0.476981016936398056576019341724673e-7,
        0.2271109460894316491031998116062124e-7,
        0.1083865921489695409107491757968159e-7,
        0.5183475041970046655121248647057669e-8,
        0.2483674543802478317185008663991718e-8,
        0.119214014058609120744254820277464e-8,
        0.5731367241678862013330194857961011e-9,
        0.2759522885124233145178149692816341e-9,
        0.1330476437424448948149715720858008e-9,
        0.6422964563838100022082448087644648e-10,
        0.3104424774732227276239215783404066e-10,
        0.1502138408075414217093301048780668e-10,
        0.7275974480239079662504549924814047e-11,
        0.3527742476575915083615072228655483e-11,
        0.1711991790559617908601084114443031e-11,
        0.8315385841420284819798357793954418e-12,
        0.4042200525289440065536008957032895e-12,
        0.1966475631096616490411045679010286e-12,
        0.9573630387838555763782200936508615e-13,
        0.4664076026428374224576492565974577e-13,
        0.2273736960065972320633279596737272e-13,
        0.1109139947083452201658320007192334e-13
    ];
    var c = 0.2273736845824652515226821577978691e-12;
    var tol_logcf = 1e-14;
    var lgam;
    var i;
    if (fabs(a) >= 0.5)
        return lgammafn_sign_1.lgammafn_sign(a + 1);
    lgam = c * logcf(-a / 2, N + 2, 1, tol_logcf);
    for (i = N - 1; i >= 0; i--)
        lgam = coeffs[i] - a * lgam;
    return (a * lgam - eulers_const) * a - log1pmx(a);
}
exports.lgamma1p = lgamma1p;
var pr_dpois_wrap = debug('dpois_wrap');
function dpois_wrap(x_plus_1, lambda, give_log) {
    pr_dpois_wrap('dpois_wrap(x+1=%d, lambda=%d, log=%s)', x_plus_1, lambda, give_log);
    if (!R_FINITE(lambda)) {
        return _general_1.R_D__0(give_log);
    }
    if (x_plus_1 > 1)
        return dpois_1.dpois_raw(x_plus_1 - 1, lambda, give_log);
    if (lambda > fabs(x_plus_1 - 1) * M_cutoff)
        return _general_1.R_D_exp(give_log, -lambda - lgammafn_sign_1.lgammafn_sign(x_plus_1));
    else {
        var d = dpois_1.dpois_raw(x_plus_1, lambda, give_log);
        pr_dpois_wrap('  -> d=dpois_raw(..)=%d', d);
        return give_log ? d + log(x_plus_1 / lambda) : d * (x_plus_1 / lambda);
    }
}
var pr_pgamma_smallx = debug('pgamma_smallx');
function pgamma_smallx(x, alph, lowerTail, logP) {
    var sum = 0;
    var c = alph;
    var n = 0;
    var term;
    pr_pgamma_smallx(' pg_smallx(x=%d, alph=%d): ', x, alph);
    do {
        n++;
        c *= -x / n;
        term = c / (alph + n);
        sum += term;
    } while (fabs(term) > DBL_EPSILON * fabs(sum));
    pr_pgamma_smallx('%d terms --> conv.sum=%d;', n, sum);
    if (lowerTail) {
        var f1 = logP ? log1p(sum) : 1 + sum;
        var f2 = void 0;
        if (alph > 1) {
            f2 = dpois_1.dpois_raw(alph, x, logP);
            f2 = logP ? f2 + x : f2 * exp(x);
        }
        else if (logP)
            f2 = alph * log(x) - lgamma1p(alph);
        else
            f2 = pow(x, alph) / exp(lgamma1p(alph));
        pr_pgamma_smallx(' (f1,f2)= (%d,%d)', f1, f2);
        return logP ? f1 + f2 : f1 * f2;
    }
    else {
        var lf2 = alph * log(x) - lgamma1p(alph);
        pr_pgamma_smallx(' 1:%d  2:%d', alph * log(x), lgamma1p(alph));
        pr_pgamma_smallx(' sum=%d  log(1+sum)=%d	 lf2=%d', sum, log1p(sum), lf2);
        if (logP)
            return expm1_1.R_Log1_Exp(log1p(sum) + lf2);
        else {
            var f1m1 = sum;
            var f2m1 = expm1(lf2);
            return -(f1m1 + f2m1 + f1m1 * f2m1);
        }
    }
}
function pd_upper_series(x, y, logP) {
    var term = x / y;
    var sum = term;
    do {
        y++;
        term *= x / y;
        sum += term;
    } while (term > sum * DBL_EPSILON);
    return logP ? log(sum) : sum;
}
var pr_pd_lower_cf = debug('pd_lower_cf');
function pd_lower_cf(y, d) {
    var f = 0.0;
    var of;
    var f0;
    var i;
    var c2;
    var c3;
    var c4;
    var a1;
    var b1;
    var a2;
    var b2;
    var max_it = 200000;
    pr_pd_lower_cf('pd_lower_cf(y=%d, d=%d)', y, d);
    if (y === 0)
        return 0;
    f0 = y / d;
    if (fabs(y - 1) < fabs(d) * DBL_EPSILON) {
        pr_pd_lower_cf(' very small "y" -> returning (y/d)');
        return f0;
    }
    if (f0 > 1)
        f0 = 1;
    c2 = y;
    c4 = d;
    a1 = 0;
    b1 = 1;
    a2 = y;
    b2 = d;
    while (b2 > scalefactor) {
        a1 /= scalefactor;
        b1 /= scalefactor;
        a2 /= scalefactor;
        b2 /= scalefactor;
    }
    i = 0;
    of = -1;
    while (i < max_it) {
        i++;
        c2--;
        c3 = i * c2;
        c4 += 2;
        a1 = c4 * a2 + c3 * a1;
        b1 = c4 * b2 + c3 * b1;
        i++;
        c2--;
        c3 = i * c2;
        c4 += 2;
        a2 = c4 * a1 + c3 * a2;
        b2 = c4 * b1 + c3 * b2;
        if (b2 !== 0) {
            f = a2 / b2;
            if (fabs(f - of) <= DBL_EPSILON * fmax2(f0, fabs(f))) {
                pr_pd_lower_cf(' %d iter.\n', i);
                return f;
            }
            of = f;
        }
    }
    pr_pd_lower_cf(" ** NON-convergence in pgamma()'s pd_lower_cf() f= %d.", f);
    return f;
}
var pr_pd_lower_series = debug('pd_lower_series');
function pd_lower_series(lambda, y) {
    var term = 1;
    var sum = 0;
    pr_pd_lower_series('pd_lower_series(lam=%d, y=%d) ...', lambda, y);
    while (y >= 1 && term > sum * DBL_EPSILON) {
        term *= y / lambda;
        sum += term;
        y--;
    }
    pr_pd_lower_series(' done: term=%d, sum=%d, y= %d', term, sum, y);
    if (y !== floor(y)) {
        var f = void 0;
        pr_pd_lower_series(' y not int: add another term ');
        f = pd_lower_cf(y, lambda + 1 - y);
        pr_pd_lower_series('  (= %d) * term = %d to sum %d', f, term * f, sum);
        sum += term * f;
    }
    return sum;
}
function dpnorm(x, lowerTail, lp) {
    if (x < 0) {
        x = -x;
        lowerTail = !lowerTail;
    }
    if (x > 10 && !lowerTail) {
        var term = 1 / x;
        var sum = term;
        var x2 = x * x;
        var i = 1;
        do {
            term *= -i / x2;
            sum += term;
            i += 2;
        } while (fabs(term) > DBL_EPSILON * sum);
        return 1 / sum;
    }
    else {
        var d = dnorm_1.dnorm4(x, 0, 1, false);
        return d / exp(lp);
    }
}
var pr_ppois_asymp = debug('ppois_asymp');
function ppois_asymp(x, lambda, lowerTail, logP) {
    var coefs_a = [
        -1e99,
        2 / 3,
        -4 / 135,
        8 / 2835,
        16 / 8505,
        -8992 / 12629925,
        -334144 / 492567075,
        698752 / 1477701225
    ];
    var coefs_b = [
        -1e99,
        1 / 12,
        1 / 288,
        -139 / 51840,
        -571 / 2488320,
        163879 / 209018880,
        5246819 / 75246796800,
        -534703531 / 902961561600
    ];
    var elfb;
    var elfb_term;
    var res12;
    var res1_term;
    var res1_ig;
    var res2_term;
    var res2_ig;
    var dfm;
    var pt_;
    var s2pt;
    var f;
    var np;
    var i;
    dfm = lambda - x;
    pt_ = -log1pmx(dfm / x);
    s2pt = sqrt(2 * x * pt_);
    if (dfm < 0)
        s2pt = -s2pt;
    res12 = 0;
    res1_ig = res1_term = sqrt(x);
    res2_ig = res2_term = s2pt;
    for (i = 1; i < 8; i++) {
        res12 += res1_ig * coefs_a[i];
        res12 += res2_ig * coefs_b[i];
        res1_term *= pt_ / i;
        res2_term *= 2 * pt_ / (2 * i + 1);
        res1_ig = res1_ig / x + res1_term;
        res2_ig = res2_ig / x + res2_term;
    }
    elfb = x;
    elfb_term = 1;
    for (i = 1; i < 8; i++) {
        elfb += elfb_term * coefs_b[i];
        elfb_term /= x;
    }
    if (!lowerTail)
        elfb = -elfb;
    pr_ppois_asymp('res12 = %d   elfb=%d', elfb, res12);
    f = res12 / elfb;
    np = pnorm_1.pnorm5(s2pt, 0.0, 1.0, !lowerTail, logP);
    if (logP) {
        var n_d_over_p = dpnorm(s2pt, !lowerTail, np);
        pr_ppois_asymp('pp*_asymp(): f=%d	 np=e^%d  nd/np=%d  f*nd/np=%d', f, np, n_d_over_p, f * n_d_over_p);
        return np + log1p(f * n_d_over_p);
    }
    else {
        var nd = dnorm_1.dnorm4(s2pt, 0, 1, logP);
        pr_ppois_asymp('pp*_asymp(): f=%d	 np=%d  nd=%d  f*nd=%d', f, np, nd, f * nd);
        return np + f * nd;
    }
}
var pr_pgamma_raw = debug('pgamma_raw');
function pgamma_raw(x, alph, lowerTail, logP) {
    if (lowerTail === void 0) { lowerTail = true; }
    if (logP === void 0) { logP = false; }
    var res;
    pr_pgamma_raw('pgamma_raw(x=%d, alph=%d, low=%s, log=%s)', x, alph, lowerTail, logP);
    var rc = _general_1.R_P_bounds_01(lowerTail, logP, x, 0, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    if (x < 1) {
        res = pgamma_smallx(x, alph, lowerTail, logP);
    }
    else if (x <= alph - 1 && x < 0.8 * (alph + 50)) {
        var sum = pd_upper_series(x, alph, logP);
        var d = dpois_wrap(alph, x, logP);
        pr_pgamma_raw(' alph "large": sum=pd_upper*()= %d, d=dpois_w(*)= %d', sum, d);
        if (!lowerTail)
            res = logP ? expm1_1.R_Log1_Exp(d + sum) : 1 - d * sum;
        else
            res = logP ? sum + d : sum * d;
    }
    else if (alph - 1 < x && alph < 0.8 * (x + 50)) {
        var sum = void 0;
        var d = dpois_wrap(alph, x, logP);
        pr_pgamma_raw('  x "large": d=dpois_w(*)= %d ', d);
        if (alph < 1) {
            if (x * DBL_EPSILON > 1 - alph)
                sum = _general_1.R_D__1(logP);
            else {
                var f = pd_lower_cf(alph, x - (alph - 1)) * x / alph;
                sum = logP ? log(f) : f;
            }
        }
        else {
            sum = pd_lower_series(x, alph - 1);
            sum = logP ? log1p(sum) : 1 + sum;
        }
        pr_pgamma_raw(', sum= %d', sum);
        if (!lowerTail)
            res = logP ? sum + d : sum * d;
        else
            res = logP ? expm1_1.R_Log1_Exp(d + sum) : 1 - d * sum;
    }
    else {
        pr_pgamma_raw(' using ppois_asymp()');
        res = ppois_asymp(alph - 1, x, !lowerTail, logP);
    }
    if (!logP && res < DBL_MIN / DBL_EPSILON) {
        pr_pgamma_raw(' very small res=%.14g; -> recompute via log\n', res);
        return exp(pgamma_raw(x, alph, lowerTail, true));
    }
    else
        return res;
}
exports.pgamma_raw = pgamma_raw;
var printer_pgamma = debug('pgamma');
function pgamma(q, shape, scale, lowerTail, logP) {
    var fa = isArray(q) ? q : [q];
    var result = fa.map(function (x) {
        if (ISNAN(x) || ISNAN(shape) || ISNAN(scale)) {
            return x + shape + scale;
        }
        if (shape < 0 || scale <= 0)
            return _general_1.ML_ERR_return_NAN(printer_pgamma);
        x /= scale;
        if (ISNAN(x))
            return x;
        if (shape === 0)
            return x <= 0
                ? _general_1.R_DT_0(lowerTail, logP)
                : _general_1.R_DT_1(lowerTail, logP);
        return pgamma_raw(x, shape, lowerTail, logP);
    });
    return result.length === 1 ? result[0] : result;
}
exports.pgamma = pgamma;
//# sourceMappingURL=pgamma.js.map