"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var toms708_1 = require("../common/toms708");
var printer = debug('dpsifn');
var ML_NAN = Number.NaN, ML_POSINF = Number.POSITIVE_INFINITY, ISNAN = Number.isNaN, DBL_EPSILON = Number.EPSILON;
var n_max = 100;
var pow = Math.pow, fabs = Math.abs, fmax2 = Math.max, fmin2 = Math.min, exp = Math.exp, log = Math.log, sin = Math.sin, cos = Math.cos, M_PI = Math.PI, round = Math.round, R_forceint = Math.round;
function dpsifn(x, n, kode, m, ans, nz, ierr) {
    var bvalues = [
        1.0,
        -5.0e-1,
        1.66666666666666667e-1,
        -3.33333333333333333e-2,
        2.38095238095238095e-2,
        -3.33333333333333333e-2,
        7.57575757575757576e-2,
        -2.53113553113553114e-1,
        1.16666666666666667,
        -7.09215686274509804,
        5.49711779448621554e1,
        -5.29124242424242424e2,
        6.1921231884057971e3,
        -8.65802531135531136e4,
        1.42551716666666667e6,
        -2.7298231067816092e7,
        6.01580873900642368e8,
        -1.51163157670921569e10,
        4.29614643061166667e11,
        -1.37116552050883328e13,
        4.88332318973593167e14,
        -1.92965793419400681e16
    ];
    var nx;
    var xinc = 0;
    var xdmln = 0;
    var i;
    var j;
    var k;
    var mm;
    var mx;
    var nn;
    var np;
    var fn;
    var arg;
    var den;
    var elim;
    var eps;
    var fln;
    var fx;
    var rln;
    var rxsq;
    var r1m4;
    var r1m5;
    var s;
    var slope;
    var t;
    var ta;
    var tk;
    var tol;
    var tols;
    var tss;
    var tst;
    var tt;
    var t1;
    var t2;
    var wdtol;
    var xdmy = 0;
    var xln = 0.0;
    var xm;
    var xmin;
    var xq;
    var yint;
    var trm = new Array(23).fill(0);
    var trmr = new Array(n_max + 1).fill(0);
    ierr.val = 0;
    if (n < 0 || kode < 1 || kode > 2 || m < 1) {
        ierr.val = 1;
        return;
    }
    if (x <= 0) {
        if (x === round(x)) {
            for (j = 0; j < m; j++)
                ans[j] = (j + n) % 2 ? ML_POSINF : ML_NAN;
            return;
        }
        dpsifn(1 - x, n, 1, m, ans, nz, ierr);
        if (m > 1 || n > 3) {
            ierr.val = 4;
            return;
        }
        x *= M_PI;
        if (n === 0)
            tt = cos(x) / sin(x);
        else if (n === 1)
            tt = -1 / _general_1.R_pow_di(sin(x), 2);
        else if (n === 2)
            tt = 2 * cos(x) / _general_1.R_pow_di(sin(x), 3);
        else if (n === 3)
            tt =
                -2 *
                    (2 * _general_1.R_pow_di(cos(x), 2) + 1) /
                    _general_1.R_pow_di(sin(x), 4);
        else
            tt = ML_NAN;
        s = n % 2 ? -1 : 1;
        t1 = t2 = s = 1;
        for (k = 0, j = k - n; j < m; k++, j++, s = -s) {
            t1 *= M_PI;
            if (k >= 2)
                t2 *= k;
            if (j >= 0)
                ans[j] = s * (ans[j] + t1 / t2 * tt);
        }
        if (n === 0 && kode === 2)
            ans[0] += xln;
        return;
    }
    nz.val = 0;
    xln = log(x);
    if (kode === 1 && m === 1) {
        var lrg = 1 / (2 * DBL_EPSILON);
        if (n === 0 && x * xln > lrg) {
            ans[0] = -xln;
            return;
        }
        else if (n >= 1 && x > n * lrg) {
            ans[0] = exp(-n * xln) / n;
            return;
        }
    }
    mm = m;
    nx = _general_1.imin2(-_general_1.DBL_MIN_EXP, _general_1.DBL_MAX_EXP);
    r1m5 = _general_1.M_LOG10_2;
    r1m4 = Number.EPSILON * 0.5;
    wdtol = fmax2(r1m4, 0.5e-18);
    elim = 2.302 * (nx * r1m5 - 3.0);
    var L10 = false;
    var L20 = false;
    var L30 = false;
    while (true) {
        nn = n + mm - 1;
        fn = nn;
        t = (fn + 1) * xln;
        if (fabs(t) > elim) {
            if (t <= 0.0) {
                nz.val = 0;
                ierr.val = 2;
                return;
            }
        }
        else {
            if (x < wdtol) {
                ans[0] = _general_1.R_pow_di(x, -n - 1);
                if (mm !== 1) {
                    for (k = 1; k < mm; k++)
                        ans[k] = ans[k - 1] / x;
                }
                if (n === 0 && kode === 2)
                    ans[0] += xln;
                return;
            }
            rln = r1m5 * _general_1.DBL_MANT_DIG;
            rln = fmin2(rln, 18.06);
            fln = fmax2(rln, 3.0) - 3.0;
            yint = 3.5 + 0.4 * fln;
            slope = 0.21 + fln * (0.0006038 * fln + 0.008677);
            xm = yint + slope * fn;
            mx = (xm >> 0) + 1;
            xmin = mx;
            if (n !== 0) {
                xm = -2.302 * rln - fmin2(0.0, xln);
                arg = xm / n;
                arg = fmin2(0.0, arg);
                eps = exp(arg);
                xm = 1.0 - eps;
                if (fabs(arg) < 1.0e-3)
                    xm = -arg;
                fln = x * xm / eps;
                xm = xmin - x;
                if (xm > 7.0 && fln < 15.0)
                    break;
            }
            xdmy = x;
            xdmln = xln;
            xinc = 0.0;
            if (x < xmin) {
                nx = x >> 0;
                xinc = xmin - nx;
                xdmy = x + xinc;
                xdmln = log(xdmy);
            }
            t = fn * xdmln;
            t1 = xdmln + xdmln;
            t2 = t + xdmln;
            tk = fmax2(fabs(t), fmax2(fabs(t1), fabs(t2)));
            if (tk <= elim) {
                L10 = true;
                break;
            }
        }
        nz.val++;
        mm--;
        ans[mm] = 0;
        if (mm === 0) {
            return;
        }
    }
    if (!L10) {
        nn = (fln >> 0) + 1;
        np = n + 1;
        t1 = (n + 1) * xln;
        t = exp(-t1);
        s = t;
        den = x;
        for (i = 1; i <= nn; i++) {
            den += 1;
            trm[i] = pow(den, -np);
            s += trm[i];
        }
        ans[0] = s;
        if (n === 0 && kode === 2)
            ans[0] = s + xln;
        if (mm !== 1) {
            tol = wdtol / 5.0;
            for (j = 1; j < mm; j++) {
                t /= x;
                s = t;
                tols = t * tol;
                den = x;
                for (i = 1; i <= nn; i++) {
                    den += 1;
                    trm[i] /= den;
                    s += trm[i];
                    if (trm[i] < tols)
                        break;
                }
                ans[j] = s;
            }
        }
        return;
    }
    tss = exp(-t);
    tt = 0.5 / xdmy;
    t1 = tt;
    tst = wdtol * tt;
    if (nn !== 0)
        t1 = tt + 1.0 / fn;
    rxsq = 1.0 / (xdmy * xdmy);
    ta = 0.5 * rxsq;
    t = (fn + 1) * ta;
    s = t * bvalues[2];
    if (fabs(s) >= tst) {
        tk = 2.0;
        for (k = 4; k <= 22; k++) {
            t = t * ((tk + fn + 1) / (tk + 1.0)) * ((tk + fn) / (tk + 2.0)) * rxsq;
            trm[k] = t * bvalues[k - 1];
            if (fabs(trm[k]) < tst)
                break;
            s += trm[k];
            tk += 2;
        }
    }
    s = (s + t1) * tss;
    while (true) {
        if (xinc !== 0.0) {
            nx = xinc >> 0;
            np = nn + 1;
            if (nx > n_max) {
                nz.val = 0;
                ierr.val = 3;
                return;
            }
            else {
                if (nn === 0) {
                    L20 = true;
                    break;
                }
                xm = xinc - 1.0;
                fx = x + xm;
                for (i = 1; i <= nx; i++) {
                    trmr[i] = pow(fx, -np);
                    s += trmr[i];
                    xm -= 1;
                    fx = x + xm;
                }
            }
        }
        ans[mm - 1] = s;
        if (fn === 0) {
            L30 = true;
            break;
        }
        for (j = 2; j <= mm; j++) {
            fn--;
            tss *= xdmy;
            t1 = tt;
            if (fn !== 0)
                t1 = tt + 1.0 / fn;
            t = (fn + 1) * ta;
            s = t * bvalues[2];
            if (fabs(s) >= tst) {
                tk = 4 + fn;
                for (k = 4; k <= 22; k++) {
                    trm[k] = trm[k] * (fn + 1) / tk;
                    if (fabs(trm[k]) < tst)
                        break;
                    s += trm[k];
                    tk += 2;
                }
            }
            s = (s + t1) * tss;
            if (xinc !== 0.0) {
                if (fn === 0) {
                    L20 = true;
                    break;
                }
                xm = xinc - 1.0;
                fx = x + xm;
                for (i = 1; i <= nx; i++) {
                    trmr[i] = trmr[i] * fx;
                    s += trmr[i];
                    xm -= 1;
                    fx = x + xm;
                }
            }
            ans[mm - j] = s;
            if (fn === 0) {
                L30 = true;
                break;
            }
        }
        return;
    }
    printer(L20 ? 'goto L20 was set!' : 'goto L20 was not set');
    if (!L30) {
        for (i = 1; i <= nx; i++) {
            s += 1 / (x + (nx - i));
        }
    }
    if (kode !== 2)
        ans[0] = s - xdmln;
    else if (xdmy !== x) {
        xq = xdmy / x;
        ans[0] = s - log(xq);
    }
    return;
}
var print_psigamma = debug('psigamma');
function psigamma(x, deriv) {
    var ans = [0];
    var nz = new toms708_1.NumberW();
    var ierr = new toms708_1.NumberW();
    var k;
    var n;
    nz.val = 0;
    ierr.val = 0;
    ans[0] = 0;
    if (ISNAN(x))
        return x;
    deriv = R_forceint(deriv);
    n = deriv >> 0;
    if (n > n_max) {
        print_psigamma('"deriv = %d > %d (= n_max)', n, n_max);
        return ML_NAN;
    }
    dpsifn(x, n, 1, 1, ans, nz, ierr);
    if (ierr.val !== 0) {
        return ML_NAN;
    }
    ans[0] = -ans[0];
    for (k = 1; k <= n; k++)
        ans[0] *= -k;
    return ans[0];
}
exports.psigamma = psigamma;
function digamma(x) {
    var ans = [0];
    var nz = new toms708_1.NumberW();
    var ierr = new toms708_1.NumberW();
    ans[0] = 0;
    nz.val = 0;
    ierr.val = 0;
    if (ISNAN(x))
        return x;
    dpsifn(x, 0, 1, 1, ans, nz, ierr);
    if (ierr.val !== 0) {
        return ML_NAN;
    }
    return -ans[0];
}
exports.digamma = digamma;
function trigamma(x) {
    var ans = [0];
    var nz = new toms708_1.NumberW(0);
    var ierr = new toms708_1.NumberW(0);
    ans[0] = 0;
    nz.val = 0;
    ierr.val = 0;
    if (ISNAN(x))
        return x;
    dpsifn(x, 1, 1, 1, ans, nz, ierr);
    if (ierr.val !== 0) {
        return ML_NAN;
    }
    return ans[0];
}
exports.trigamma = trigamma;
function tetragamma(x) {
    var ans = [0];
    var nz = new toms708_1.NumberW();
    var ierr = new toms708_1.NumberW();
    ans[0] = 0;
    nz.val = 0;
    ierr.val = 0;
    if (ISNAN(x))
        return x;
    dpsifn(x, 2, 1, 1, ans, nz, ierr);
    if (ierr.val !== 0) {
        return ML_NAN;
    }
    return -2.0 * ans[0];
}
exports.tetragamma = tetragamma;
function pentagamma(x) {
    var ans = [0];
    var nz = new toms708_1.NumberW();
    var ierr = new toms708_1.NumberW();
    ans[0] = 0;
    nz.val = 0;
    ierr.val = 0;
    if (ISNAN(x))
        return x;
    dpsifn(x, 3, 1, 1, ans, nz, ierr);
    if (ierr.val !== 0) {
        return ML_NAN;
    }
    return 6.0 * ans[0];
}
exports.pentagamma = pentagamma;
//# sourceMappingURL=polygamma.js.map