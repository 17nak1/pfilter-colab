"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var tanpi_1 = require("../trigonometry/tanpi");
var expm1 = Math.expm1, exp = Math.exp;
var ISNAN = Number.isNaN, R_FINITE = Number.isFinite;
var _a = {
    ML_POSINF: Infinity,
    ML_NEGINF: -Infinity
}, ML_POSINF = _a.ML_POSINF, ML_NEGINF = _a.ML_NEGINF;
var printer = debug('qcauchy');
function qcauchy(p, location, scale, lowerTail, logP) {
    if (location === void 0) { location = 0; }
    if (scale === void 0) { scale = 1; }
    if (lowerTail === void 0) { lowerTail = true; }
    if (logP === void 0) { logP = false; }
    if (ISNAN(p) || ISNAN(location) || ISNAN(scale))
        return NaN;
    var lower_tail = lowerTail;
    var rc = _general_1.R_Q_P01_check(logP, p);
    if (rc !== undefined) {
        return rc;
    }
    if (scale <= 0 || !R_FINITE(scale)) {
        if (scale === 0)
            return location;
        return _general_1.ML_ERR_return_NAN(printer);
    }
    var my_INF = location + (lower_tail ? scale : -scale) * ML_POSINF;
    if (logP) {
        if (p > -1) {
            if (p === 0)
                return my_INF;
            lower_tail = !lower_tail;
            p = -expm1(p);
        }
        else
            p = exp(p);
    }
    else {
        if (p > 0.5) {
            if (p === 1)
                return my_INF;
            p = 1 - p;
            lower_tail = !lower_tail;
        }
    }
    if (p === 0.5)
        return location;
    if (p === 0)
        return location + (lower_tail ? scale : -scale) * ML_NEGINF;
    return location + (lower_tail ? -scale : scale) / tanpi_1.tanpi(p);
}
exports.qcauchy = qcauchy;
//# sourceMappingURL=qcauchy.js.map