"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../../common/_general");
var cospi_1 = require("../../trigonometry/cospi");
var sinpi_1 = require("../../trigonometry/sinpi");
var besselJ_1 = require("../besselJ");
var Ybessel_1 = require("./Ybessel");
var floor = Math.floor;
var ISNAN = Number.isNaN, ML_POSINF = Number.POSITIVE_INFINITY;
var printer = debug('bessel_y');
function bessel_y(x, alpha) {
    if (ISNAN(x) || ISNAN(alpha))
        return x + alpha;
    if (x < 0) {
        _general_1.ML_ERROR(_general_1.ME.ME_RANGE, 'bessel_y', printer);
        return NaN;
    }
    var na = floor(alpha);
    if (alpha < 0) {
        return (((alpha - na === 0.5) ? 0 : bessel_y(x, -alpha) * cospi_1.cospi(alpha)) -
            ((alpha === na) ? 0 : besselJ_1.bessel_j(x, -alpha) * sinpi_1.sinpi(alpha)));
    }
    else if (alpha > 1e7) {
        printer('besselY(x, nu): nu=%d too large for bessel_y() algorithm', alpha);
        return NaN;
    }
    var nb = 1 + na;
    alpha -= (nb - 1);
    var rc = Ybessel_1.Y_bessel(x, alpha, nb);
    if (rc.ncalc !== nb) {
        if (rc.ncalc === -1) {
            return ML_POSINF;
        }
        else if (rc.ncalc < -1)
            printer('bessel_y(%d): ncalc (=%d) != nb (=%d); alpha=%d. Arg. out of range?\n', rc.x, rc.ncalc, nb, alpha);
        else
            printer('bessel_y(%d,nu=%d): precision lost in result\n', rc.x, alpha + nb - 1);
    }
    x = rc.x;
    return x;
}
exports.bessel_y = bessel_y;
//# sourceMappingURL=index.js.map