"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../../common/_general");
var gamma_cody_1 = require("../../gamma/gamma_cody");
var bessel_constants_1 = require("../bessel-constants");
var min = Math.min, trunc = Math.trunc, pow = Math.pow, sqrt = Math.sqrt, sin = Math.sin, cos = Math.cos, max = Math.max, abs = Math.abs;
var printer = debug('J_bessel');
function J_bessel(x, alpha, nb) {
    var pi2 = .636619772367581343075535;
    var twopi1 = 6.28125;
    var twopi2 = .001935307179586476925286767;
    var fact = [1., 1., 2., 6., 24., 120., 720., 5040., 40320.,
        362880., 3628800., 39916800., 479001600., 6227020800., 87178291200.,
        1.307674368e12, 2.0922789888e13, 3.55687428096e14, 6.402373705728e15,
        1.21645100408832e17, 2.43290200817664e18, 5.109094217170944e19,
        1.12400072777760768e21, 2.585201673888497664e22,
        6.2044840173323943936e23];
    var b2 = new Array(nb).fill(0);
    var i_nend;
    var nbmx;
    var i;
    var j;
    var l;
    var i_m;
    var n;
    var nstart;
    var capp;
    var capq;
    var pold;
    var vcos;
    var test;
    var vsin;
    var p;
    var s;
    var t;
    var z;
    var alpem;
    var halfx;
    var aa;
    var bb;
    var cc;
    var psave;
    var plast;
    var tover;
    var t1;
    var alp2em;
    var em;
    var en;
    var xc;
    var xk;
    var xm;
    var psavel;
    var gnu;
    var xin;
    var sum;
    var ncalc;
    var gotoL190 = false;
    var nu = alpha;
    var twonu = nu + nu;
    if (!(nb > 0 && x >= 0. && 0. <= nu && nu < 1.)) {
        b2[0] = 0.;
        ncalc = min(nb, 0) - 1;
        return { x: x, nb: nb, ncalc: ncalc };
    }
    ncalc = nb;
    if (x > bessel_constants_1.xlrg_BESS_IJ) {
        _general_1.ML_ERROR(_general_1.ME.ME_RANGE, 'J_bessel', printer);
        return { x: 0, nb: nb, ncalc: ncalc };
    }
    var intxj = trunc(x);
    if (x < 1 / 10000) {
        printer('x < 0.0001 , x=%d, nb=%d', x, nb);
        alpem = 1. + nu;
        halfx = (x > bessel_constants_1.enmten_BESS) ? .5 * x : 0.;
        aa = (nu !== 0.) ? pow(halfx, nu) / (nu * gamma_cody_1.Rf_gamma_cody(nu)) : 1.;
        bb = (x + 1. > 1.) ? -halfx * halfx : 0.;
        b2[0] = aa + aa * bb / alpem;
        if (x !== 0. && b2[0] === 0.)
            ncalc = 0;
        if (nb !== 1) {
            if (x <= 0.) {
                for (n = 2; n <= nb; ++n)
                    b2[n - 1] = 0.;
            }
            else {
                if (bb === 0.)
                    tover = (bessel_constants_1.enmten_BESS + bessel_constants_1.enmten_BESS) / x;
                else
                    tover = bessel_constants_1.enmten_BESS / bb;
                cc = halfx;
                for (n = 2; n <= nb; ++n) {
                    aa /= alpem;
                    alpem += 1.;
                    aa *= cc;
                    if (aa <= tover * alpem)
                        aa = 0.;
                    b2[n - 1] = aa + aa * bb / alpem;
                    if (b2[n - 1] === 0. && ncalc > n)
                        ncalc = n - 1;
                }
            }
        }
    }
    else if (x > 25. && nb <= intxj + 1) {
        printer('x > 25 and nb < int(x+1) :x=%d, nb=%d', x, nb);
        xc = sqrt(pi2 / x);
        xin = 1 / (64 * x * x);
        if (x >= 130.)
            i_m = 4;
        else if (x >= 35.)
            i_m = 8;
        else
            i_m = 11;
        xm = 4. * i_m;
        t = trunc(x / (twopi1 + twopi2) + .5);
        z = (x - t * twopi1) - t * twopi2 - (nu + .5) / pi2;
        vsin = sin(z);
        vcos = cos(z);
        gnu = twonu;
        for (i = 1; i <= 2; ++i) {
            s = (xm - 1. - gnu) * (xm - 1. + gnu) * xin * .5;
            t = (gnu - (xm - 3.)) * (gnu + (xm - 3.));
            t1 = (gnu - (xm + 1.)) * (gnu + (xm + 1.));
            var k = i_m + i_m;
            capp = s * t / fact[k];
            capq = s * t1 / fact[k + 1];
            xk = xm;
            for (; k >= 4; k -= 2) {
                xk -= 4.;
                s = (xk - 1. - gnu) * (xk - 1. + gnu);
                t1 = t;
                t = (gnu - (xk - 3.)) * (gnu + (xk - 3.));
                capp = (capp + 1. / fact[k - 2]) * s * t * xin;
                capq = (capq + 1. / fact[k - 1]) * s * t1 * xin;
            }
            capp += 1.;
            capq = (capq + 1.) * (gnu * gnu - 1.) * (.125 / x);
            b2[i - 1] = xc * (capp * vcos - capq * vsin);
            if (nb === 1) {
                return { x: b2[nb - 1], nb: nb, ncalc: ncalc };
            }
            t = vsin;
            vsin = -vcos;
            vcos = t;
            gnu += 2.;
        }
        if (nb > 2)
            for (gnu = twonu + 2., j = 3; j <= nb; j++, gnu += 2.)
                b2[j - 1] = gnu * b2[j - 1 - 1] / x - b2[j - 2 - 1];
    }
    else {
        printer('rest: x=%d, nb=%d\t', x, nb);
        nbmx = nb - intxj;
        n = intxj + 1;
        en = (n + n) + twonu;
        plast = 1.;
        p = en / x;
        test = bessel_constants_1.ensig_BESS + bessel_constants_1.ensig_BESS;
        if (nbmx >= 3) {
            tover = bessel_constants_1.enten_BESS / bessel_constants_1.ensig_BESS;
            nstart = intxj + 2;
            i_nend = nb - 1;
            en = (nstart + nstart) - 2. + twonu;
            for (var k = nstart; k <= i_nend; ++k) {
                n = k;
                en += 2.;
                pold = plast;
                plast = p;
                p = en * plast / x - pold;
                if (p > tover) {
                    tover = bessel_constants_1.enten_BESS;
                    p /= tover;
                    plast /= tover;
                    psave = p;
                    psavel = plast;
                    nstart = n + 1;
                    do {
                        ++n;
                        en += 2.;
                        pold = plast;
                        plast = p;
                        p = en * plast / x - pold;
                    } while (p <= 1.);
                    bb = en / x;
                    test = pold * plast * (.5 - .5 / (bb * bb));
                    test /= bessel_constants_1.ensig_BESS;
                    p = plast * tover;
                    --n;
                    en -= 2.;
                    i_nend = min(nb, n);
                    for (l = nstart; l <= i_nend; ++l) {
                        pold = psavel;
                        psavel = psave;
                        psave = en * psavel / x - pold;
                        if (psave * psavel > test) {
                            ncalc = l - 1;
                            break;
                        }
                        ncalc = l;
                    }
                    gotoL190 = true;
                    break;
                }
            }
            n = i_nend;
            en = (n + n) + twonu;
            test = max(test, sqrt(plast * bessel_constants_1.ensig_BESS) * sqrt(p + p));
        }
        if (!gotoL190) {
            do {
                ++n;
                en += 2.;
                pold = plast;
                plast = p;
                p = en * plast / x - pold;
            } while (p < test);
        }
        ++n;
        en += 2.;
        bb = 0.;
        aa = 1. / p;
        em = i_m = n >> 1;
        i_m = (n << 1) - (i_m << 2);
        if (i_m === 0)
            sum = 0.;
        else {
            alpem = em - 1. + nu;
            alp2em = em + em + nu;
            sum = aa * alpem * alp2em / em;
        }
        i_nend = n - nb;
        for (l = 1; l <= i_nend; ++l) {
            --n;
            en -= 2.;
            cc = bb;
            bb = aa;
            aa = en * bb / x - cc;
            i_m = i_m ? 0 : 2;
            if (i_m !== 0) {
                em -= 1.;
                alp2em = em + em + nu;
                if (n === 1)
                    break;
                alpem = em - 1. + nu;
                if (alpem === 0.)
                    alpem = 1.;
                sum = (sum + aa * alp2em) * alpem / em;
            }
        }
        b2[n - 1] = aa;
        var gotoL240 = false;
        var gotoL250 = false;
        for (var cnt = 1; cnt > 0; cnt--) {
            if (i_nend >= 0) {
                if (nb <= 1) {
                    if (nu + 1. === 1.)
                        alp2em = 1.;
                    else
                        alp2em = nu;
                    sum += b2[0] * alp2em;
                    gotoL250 = true;
                    break;
                }
                else {
                    --n;
                    en -= 2.;
                    b2[n - 1] = en * aa / x - bb;
                    if (n === 1) {
                        gotoL240 = true;
                        break;
                    }
                    i_m = i_m ? 0 : 2;
                    if (i_m !== 0) {
                        em -= 1.;
                        alp2em = em + em + nu;
                        alpem = em - 1. + nu;
                        if (alpem === 0.)
                            alpem = 1.;
                        sum = (sum + b2[n - 1] * alp2em) * alpem / em;
                    }
                }
            }
        }
        if (gotoL250 === false && gotoL240 === false) {
            for (n = n - 1; n >= 2; n--) {
                en -= 2.;
                b2[n - 1] = en * b2[n + 1 - 1] / x - b2[n + 2 - 1];
                i_m = i_m ? 0 : 2;
                if (i_m !== 0) {
                    em -= 1.;
                    alp2em = em + em + nu;
                    alpem = em - 1. + nu;
                    if (alpem === 0.)
                        alpem = 1.;
                    sum = (sum + b2[n - 1] * alp2em) * alpem / em;
                }
            }
            b2[0] = 2. * (nu + 1.) * b2[1] / x - b2[2];
        }
        if (gotoL250 === false) {
            em -= 1.;
            alp2em = em + em + nu;
            if (alp2em === 0.)
                alp2em = 1.;
            sum += b2[0] * alp2em;
        }
        if (abs(nu) > 1e-15)
            sum *= (gamma_cody_1.Rf_gamma_cody(nu) * pow(.5 * x, -nu));
        aa = bessel_constants_1.enmten_BESS;
        if (sum > 1.)
            aa *= sum;
        for (n = 1; n <= nb; ++n) {
            if (abs(b2[n - 1]) < aa)
                b2[n - 1] = 0.;
            else
                b2[n - 1] /= sum;
        }
    }
    return { x: b2[nb - 1], nb: nb, ncalc: ncalc };
}
exports.J_bessel = J_bessel;
//# sourceMappingURL=Jbessel.js.map