"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var gamma_cody_1 = require("../../gamma/gamma_cody");
var bessel_constants_1 = require("../bessel-constants");
var sqrt = Math.sqrt, pow = Math.pow, min = Math.min, fmax = Math.max, exp = Math.exp, trunc = Math.trunc;
var ML_POSINF = Number.POSITIVE_INFINITY;
var printer = debug('I_bessel');
function I_bessel(x, alpha, nb, ize) {
    var const__ = 1.585;
    var nend;
    var intx;
    var nbmx;
    var k;
    var l;
    var n;
    var nstart;
    var pold;
    var test;
    var p;
    var em;
    var en;
    var empal;
    var emp2al;
    var halfx;
    var aa;
    var bb;
    var cc;
    var psave;
    var plast;
    var tover;
    var psavel;
    var sum;
    var nu;
    var twonu;
    var ncalc = nb;
    var bi2 = new Array(nb).fill(0);
    nu = alpha;
    twonu = nu + nu;
    if (nb > 0 && x >= 0. && (0. <= nu && nu < 1.) &&
        (1 <= ize && ize <= 2)) {
        ncalc = nb;
        if (ize === 1 && x > bessel_constants_1.exparg_BESS) {
            return { x: ML_POSINF, nb: nb, ncalc: ncalc };
        }
        if (ize === 2 && x > bessel_constants_1.xlrg_BESS_IJ) {
            return { x: 0., nb: nb, ncalc: ncalc };
        }
        intx = trunc(x);
        if (x >= bessel_constants_1.rtnsig_BESS) {
            nbmx = nb - intx;
            n = intx + 1;
            en = (n + n) + twonu;
            plast = 1.;
            p = en / x;
            test = bessel_constants_1.ensig_BESS + bessel_constants_1.ensig_BESS;
            if (intx * 2 > bessel_constants_1.nsig_BESS * 5) {
                test = sqrt(test * p);
            }
            else {
                test /= pow(const__, intx);
            }
            var gotoL120 = false;
            if (nbmx >= 3) {
                tover = bessel_constants_1.enten_BESS / bessel_constants_1.ensig_BESS;
                nstart = intx + 2;
                nend = nb - 1;
                for (k = nstart; k <= nend; ++k) {
                    n = k;
                    en += 2.;
                    pold = plast;
                    plast = p;
                    p = en * plast / x + pold;
                    if (p > tover) {
                        tover = bessel_constants_1.enten_BESS;
                        p /= tover;
                        plast /= tover;
                        psave = p;
                        psavel = plast;
                        nstart = n + 1;
                        do {
                            ++n;
                            en += 2.;
                            pold = plast;
                            plast = p;
                            p = en * plast / x + pold;
                        } while (p <= 1.);
                        bb = en / x;
                        test = pold * plast / bessel_constants_1.ensig_BESS;
                        test *= .5 - .5 / (bb * bb);
                        p = plast * tover;
                        --n;
                        en -= 2.;
                        nend = min(nb, n);
                        for (l = nstart; l <= nend; ++l) {
                            ncalc = l - 1;
                            pold = psavel;
                            psavel = psave;
                            psave = en * psavel / x + pold;
                            if (psave * psavel > test) {
                                break;
                            }
                            ncalc = nend;
                        }
                        gotoL120 = true;
                        break;
                    }
                }
                if (gotoL120 === false) {
                    n = nend;
                    en = (n + n) + twonu;
                    test = fmax(test, sqrt(plast * bessel_constants_1.ensig_BESS) * sqrt(p + p));
                }
            }
            if (gotoL120 === false) {
                do {
                    ++n;
                    en += 2.;
                    pold = plast;
                    plast = p;
                    p = en * plast / x + pold;
                } while (p < test);
            }
            ++n;
            en += 2.;
            bb = 0.;
            aa = 1. / p;
            em = n - 1.;
            empal = em + nu;
            emp2al = em - 1. + twonu;
            sum = aa * empal * emp2al / em;
            nend = n - nb;
            var gotoL230 = false;
            for (var cnt = 0; cnt < 1; cnt++) {
                if (nend < 0) {
                    bi2[n - 1] = aa;
                    nend = -nend;
                    for (l = 1; l <= nend; ++l) {
                        bi2[n + l - 1] = 0.;
                    }
                }
                else {
                    if (nend > 0) {
                        for (l = 1; l <= nend; ++l) {
                            --n;
                            en -= 2.;
                            cc = bb;
                            bb = aa;
                            if (nend > 100 && aa > 1e200) {
                                var pow05_to_900 = pow(2, -900);
                                cc = cc * pow05_to_900;
                                bb = bb * pow05_to_900;
                                sum = sum * pow05_to_900;
                            }
                            aa = en * bb / x + cc;
                            em -= 1.;
                            emp2al -= 1.;
                            if (n === 1) {
                                break;
                            }
                            if (n === 2) {
                                emp2al = 1.;
                            }
                            empal -= 1.;
                            sum = (sum + aa * empal) * emp2al / em;
                        }
                    }
                    bi2[n - 1] = aa;
                    if (nb <= 1) {
                        sum = sum + sum + aa;
                        gotoL230 = true;
                        break;
                    }
                    --n;
                    en -= 2.;
                    bi2[n - 1] = en * aa / x + bb;
                    if (n === 1) {
                        break;
                    }
                    em -= 1.;
                    if (n === 2)
                        emp2al = 1.;
                    else
                        emp2al -= 1.;
                    empal -= 1.;
                    sum = (sum + bi2[n - 1] * empal) * emp2al / em;
                }
                nend = n - 2;
                if (nend > 0) {
                    for (l = 1; l <= nend; ++l) {
                        --n;
                        en -= 2.;
                        bi2[n - 1] = en * bi2[n] / x + bi2[n + 1];
                        em -= 1.;
                        if (n === 2)
                            emp2al = 1.;
                        else
                            emp2al -= 1.;
                        empal -= 1.;
                        sum = (sum + bi2[n - 1] * empal) * emp2al / em;
                    }
                }
                bi2[0] = 2. * empal * bi2[1] / x + bi2[2];
            }
            if (gotoL230 === false) {
                sum = sum + sum + bi2[0];
            }
            if (nu !== 0.)
                sum *= (gamma_cody_1.Rf_gamma_cody(1. + nu) * pow(x * .5, -nu));
            if (ize === 1)
                sum *= exp(-(x));
            aa = bessel_constants_1.enmten_BESS;
            if (sum > 1.)
                aa *= sum;
            for (n = 1; n <= nb; ++n) {
                if (bi2[n - 1] < aa)
                    bi2[n - 1] = 0.;
                else
                    bi2[n - 1] /= sum;
            }
            var rc_1 = { x: bi2[nb - 1], nb: nb, ncalc: ncalc };
            printer('normalize, devide all  Bi[N] by sum, result:%o', rc_1);
            return rc_1;
        }
        else {
            aa = 1.;
            empal = 1. + nu;
            halfx = .5 * x;
            if (nu !== 0.)
                aa = pow(halfx, nu) / gamma_cody_1.Rf_gamma_cody(empal);
            if (ize === 2)
                aa *= exp(-(x));
            bb = halfx * halfx;
            bi2[0] = aa + aa * bb / empal;
            if (x !== 0. && bi2[0] === 0.)
                ncalc = 0;
            if (nb > 1) {
                if (x === 0.) {
                    for (n = 2; n <= nb; ++n)
                        bi2[n - 1] = 0.;
                }
                else {
                    cc = halfx;
                    tover = (bessel_constants_1.enmten_BESS + bessel_constants_1.enmten_BESS) / x;
                    if (bb !== 0.)
                        tover = bessel_constants_1.enmten_BESS / bb;
                    for (n = 2; n <= nb; ++n) {
                        aa /= empal;
                        empal += 1.;
                        aa *= cc;
                        if (aa <= tover * empal)
                            bi2[n - 1] = aa = 0.;
                        else
                            bi2[n - 1] = aa + aa * bb / empal;
                        if (bi2[n - 1] === 0. && ncalc > n)
                            ncalc = n - 1;
                    }
                }
            }
        }
    }
    else {
        ncalc = min(nb, 0) - 1;
    }
    var rc = { x: bi2[nb - 1], nb: nb, ncalc: ncalc };
    printer('drop off, result:%o', rc);
    return rc;
}
exports.I_bessel = I_bessel;
//# sourceMappingURL=IBessel.js.map