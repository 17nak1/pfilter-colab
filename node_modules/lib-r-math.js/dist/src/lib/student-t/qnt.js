'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var expm1_1 = require("../exp/expm1");
var qnorm_1 = require("../normal/qnorm");
var pnt_1 = require("./pnt");
var qt_1 = require("./qt");
var fabs = Math.abs, fmax2 = Math.max, fmin2 = Math.min;
var DBL_MAX = Number.MAX_VALUE, DBL_EPSILON = Number.EPSILON, R_FINITE = Number.isFinite, ML_POSINF = Number.POSITIVE_INFINITY, ML_NEGINF = Number.NEGATIVE_INFINITY, ISNAN = Number.isNaN;
var printer = debug('qnt');
function qnt(p, df, ncp, lower_tail, log_p) {
    var accu = 1e-13;
    var Eps = 1e-11;
    var ux;
    var lx;
    var nx;
    var pp;
    if (ISNAN(p) || ISNAN(df) || ISNAN(ncp))
        return p + df + ncp;
    if (df <= 0.0)
        return _general_1.ML_ERR_return_NAN(printer);
    if (ncp === 0.0 && df >= 1.0)
        return qt_1.qt(p, df, lower_tail, log_p);
    var rc = _general_1.R_Q_P01_boundaries(lower_tail, log_p, p, ML_NEGINF, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    if (!R_FINITE(df))
        return qnorm_1.qnorm(p, ncp, 1, lower_tail, log_p);
    p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
    if (p > 1 - DBL_EPSILON)
        return ML_POSINF;
    pp = fmin2(1 - DBL_EPSILON, p * (1 + Eps));
    for (ux = fmax2(1, ncp); ux < DBL_MAX && pnt_1.pnt(ux, df, ncp, true, false) < pp; ux *= 2)
        ;
    pp = p * (1 - Eps);
    for (lx = fmin2(-1, -ncp); lx > -DBL_MAX && pnt_1.pnt(lx, df, ncp, true, false) > pp; lx *= 2)
        ;
    do {
        nx = 0.5 * (lx + ux);
        if (pnt_1.pnt(nx, df, ncp, true, false) > p)
            ux = nx;
        else
            lx = nx;
    } while (ux - lx > accu * fmax2(fabs(lx), fabs(ux)));
    return 0.5 * (lx + ux);
}
exports.qnt = qnt;
//# sourceMappingURL=qnt.js.map