'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var expm1_1 = require("../exp/expm1");
var qnorm_1 = require("../normal/qnorm");
var cospi_1 = require("../trigonometry/cospi");
var dt_1 = require("./dt");
var pt_1 = require("./pt");
var M_LN2 = Math.LN2, M_PI = Math.PI, M_SQRT2 = Math.SQRT2, sqrt = Math.sqrt, pow = Math.pow, log = Math.log, exp = Math.exp, fmin2 = Math.min, fabs = Math.abs, expm1 = Math.expm1;
var ISNAN = Number.isNaN, DBL_EPSILON = Number.EPSILON, DBL_MAX = Number.MAX_VALUE, DBL_MIN = Number.MIN_VALUE, ML_POSINF = Number.POSITIVE_INFINITY, ML_NEGINF = Number.NEGATIVE_INFINITY, R_FINITE = Number.isFinite;
var printer_qt = debug('qt');
function qt(p, ndf, lower_tail, log_p) {
    var eps = 1e-12;
    var P;
    var q;
    var accu = 1e-13;
    var Eps = 1e-11;
    if (ISNAN(p) || ISNAN(ndf))
        return p + ndf;
    var rc = _general_1.R_Q_P01_boundaries(lower_tail, log_p, p, ML_NEGINF, ML_POSINF);
    if (rc !== undefined) {
        return rc;
    }
    if (ndf <= 0)
        return _general_1.ML_ERR_return_NAN(printer_qt);
    if (ndf < 1) {
        var ux = void 0;
        var lx = void 0;
        var nx = void 0;
        var pp = void 0;
        var iter = 0;
        p = expm1_1.R_DT_qIv(lower_tail, log_p, p);
        if (p > 1 - DBL_EPSILON)
            return ML_POSINF;
        pp = fmin2(1 - DBL_EPSILON, p * (1 + Eps));
        for (ux = 1; ux < DBL_MAX && pt_1.pt(ux, ndf, true, false) < pp; ux *= 2)
            ;
        pp = p * (1 - Eps);
        for (lx = -1; lx > -DBL_MAX && pt_1.pt(lx, ndf, true, false) > pp; lx *= 2)
            ;
        do {
            nx = 0.5 * (lx + ux);
            if (pt_1.pt(nx, ndf, true, false) > p)
                ux = nx;
            else
                lx = nx;
        } while ((ux - lx) / fabs(nx) > accu && ++iter < 1000);
        if (iter >= 1000) {
            _general_1.ML_ERROR(_general_1.ME.ME_PRECISION, 'qt', printer_qt);
        }
        return 0.5 * (lx + ux);
    }
    if (ndf > 1e20)
        return qnorm_1.qnorm(p, 0, 1, lower_tail, log_p);
    P = _general_1.R_D_qIv(log_p, p);
    var neg = (!lower_tail || P < 0.5) && (lower_tail || P > 0.5);
    var is_neg_lower = lower_tail === neg;
    if (neg)
        P = 2 * (log_p ? (lower_tail ? P : -expm1(p)) : _general_1.R_D_Lval(lower_tail, p));
    else
        P = 2 * (log_p ? (lower_tail ? -expm1(p) : P) : _general_1.R_D_Cval(lower_tail, p));
    if (fabs(ndf - 2) < eps) {
        if (P > DBL_MIN) {
            if (3 * P < DBL_EPSILON)
                q = 1 / sqrt(P);
            else if (P > 0.9)
                q = (1 - P) * sqrt(2 / (P * (2 - P)));
            else
                q = sqrt(2 / (P * (2 - P)) - 2);
        }
        else {
            if (log_p)
                q = is_neg_lower ? exp(-p / 2) / M_SQRT2 : 1 / sqrt(-expm1(p));
            else
                q = ML_POSINF;
        }
    }
    else if (ndf < 1 + eps) {
        if (P === 1)
            q = 0;
        else if (P > 0)
            q = 1 / cospi_1.tanpi(P / 2);
        else {
            if (log_p)
                q = is_neg_lower ? _general_1.M_1_PI * exp(-p) : -1 / (M_PI * expm1(p));
            else
                q = ML_POSINF;
        }
    }
    else {
        var x = 0;
        var y = 0;
        var log_P2 = 0;
        var a = 1 / (ndf - 0.5);
        var b = 48 / (a * a);
        var c = ((20700 * a / b - 98) * a - 16) * a + 96.36;
        var d = ((94.5 / (b + c) - 3) / b + 1) * sqrt(a * _general_1.M_PI_2) * ndf;
        var P_ok1 = P > DBL_MIN || !log_p;
        var P_ok = P_ok1;
        if (P_ok1) {
            y = pow(d * P, 2.0 / ndf);
            P_ok = y >= DBL_EPSILON;
        }
        if (!P_ok) {
            log_P2 = is_neg_lower
                ? _general_1.R_D_log(log_p, p)
                : expm1_1.R_D_LExp(log_p, p);
            x = (log(d) + M_LN2 + log_P2) / ndf;
            y = exp(2 * x);
        }
        if ((ndf < 2.1 && P > 0.5) || y > 0.05 + a) {
            if (P_ok)
                x = qnorm_1.qnorm(0.5 * P, 0, 1, false, false);
            else
                x = qnorm_1.qnorm(log_P2, 0, 1, lower_tail, true);
            y = x * x;
            if (ndf < 5)
                c += 0.3 * (ndf - 4.5) * (x + 0.6);
            c = (((0.05 * d * x - 5) * x - 7) * x - 2) * x + b + c;
            y = (((((0.4 * y + 6.3) * y + 36) * y + 94.5) / c - y - 3) / b + 1) * x;
            y = expm1(a * y * y);
            q = sqrt(ndf * y);
        }
        else if (!P_ok && x < -M_LN2 * _general_1.DBL_MANT_DIG) {
            q = sqrt(ndf) * exp(-x);
        }
        else {
            y =
                ((1 / (((ndf + 6) / (ndf * y) - 0.089 * d - 0.822) * (ndf + 2) * 3) +
                    0.5 / (ndf + 4)) *
                    y -
                    1) *
                    (ndf + 1) /
                    (ndf + 2) +
                    1 / y;
            q = sqrt(ndf * y);
        }
        if (P_ok1) {
            var it_1 = 0;
            while (it_1++ < 10 &&
                (y = dt_1.dt(q, ndf, false)) > 0 &&
                R_FINITE((x = (pt_1.pt(q, ndf, false, false) - P / 2) / y)) &&
                fabs(x) > 1e-14 * fabs(q))
                q += x * (1 + x * q * (ndf + 1) / (2 * (q * q + ndf)));
        }
    }
    if (neg)
        q = -q;
    return q;
}
exports.qt = qt;
//# sourceMappingURL=qt.js.map