"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var debug_R_Q_P01_boundaries = debug('R_Q_P01_boundaries');
var debug_R_Q_P01_check = debug('R_Q_P01_check');
exports.M_SQRT2 = 1.41421356237309504880168872421;
exports.frac = function (x) { return x - Math.trunc(x); };
exports.M_SQRT_32 = 5.656854249492380195206754896838;
exports.DBL_MANT_DIG = 18;
exports.M_LN2 = 0.693147180559945309417232121458;
exports.M_1_SQRT_2PI = 0.398942280401432677939946059934;
exports.M_2PI = 6.283185307179586476925286766559;
exports.M_LN_2PI = 1.837877066409345483560659472811;
exports.M_1_PI = 1.0 / Math.PI;
exports.M_PI_2 = Math.PI / 2;
exports.M_LN_SQRT_PI = 0.57236494292470008;
exports.M_LN_SQRT_2PI = 0.918938533204672741780329736406;
exports.M_LN_SQRT_PId2 = 0.225791352644727432363097614947;
exports.M_SQRT_2dPI = 0.797884560802865355879892119869;
exports.M_LOG10_2 = 0.301029995663981195213738894724;
exports.DBL_MAX_EXP = Math.log2(Number.MAX_VALUE);
exports.DBL_MIN_EXP = Math.log2(Number.MIN_VALUE);
exports.R_D__1 = function (logP) {
    return logP ? 0 : 1.0;
};
exports.R_D__0 = function (logP) {
    return logP ? Number.NEGATIVE_INFINITY : 0.0;
};
exports.R_DT_0 = function (lower_tail, log_p) {
    return lower_tail ? exports.R_D__0(log_p) : exports.R_D__1(log_p);
};
exports.R_DT_1 = function (lower_tail, log_p) {
    return lower_tail ? exports.R_D__1(log_p) : exports.R_D__0(log_p);
};
exports.R_D_val = function (log_p, x) {
    return log_p ? Math.log(x) : x;
};
function R_D_Clog(log_p, p) {
    return log_p ? Math.log1p(-p) : 0.5 - p + 0.5;
}
exports.R_D_Clog = R_D_Clog;
function R_DT_val(lower_tail, log_p, x) {
    return lower_tail ? exports.R_D_val(log_p, x) : R_D_Clog(log_p, x);
}
exports.R_DT_val = R_DT_val;
function imin2(x, y) {
    return Math.trunc(Math.min(x, y));
}
exports.imin2 = imin2;
function R_D_Lval(lowerTail, p) {
    return lowerTail ? p : 1 - p;
}
exports.R_D_Lval = R_D_Lval;
function R_D_Cval(lowerTail, p) {
    return lowerTail ? 1 - p : p;
}
exports.R_D_Cval = R_D_Cval;
function R_P_bounds_Inf_01(lowerTail, log_p, x) {
    if (!Number.isFinite(x)) {
        if (x > 0) {
            return exports.R_DT_1(lowerTail, log_p);
        }
        return exports.R_DT_0(lowerTail, log_p);
    }
    return undefined;
}
exports.R_P_bounds_Inf_01 = R_P_bounds_Inf_01;
function R_D_half(log_p) {
    return log_p ? -exports.M_LN2 : 0.5;
}
exports.R_D_half = R_D_half;
function R_P_bounds_01(lower_tail, log_p, x, x_min, x_max) {
    if (x <= x_min)
        return exports.R_DT_0(lower_tail, log_p);
    if (x >= x_max)
        return exports.R_DT_1(lower_tail, log_p);
    return undefined;
}
exports.R_P_bounds_01 = R_P_bounds_01;
exports.R_D_exp = function (log_p, x) {
    return log_p ? x : Math.exp(x);
};
var ME;
(function (ME) {
    ME[ME["ME_NONE"] = 0] = "ME_NONE";
    ME[ME["ME_DOMAIN"] = 1] = "ME_DOMAIN";
    ME[ME["ME_RANGE"] = 2] = "ME_RANGE";
    ME[ME["ME_NOCONV"] = 4] = "ME_NOCONV";
    ME[ME["ME_PRECISION"] = 8] = "ME_PRECISION";
    ME[ME["ME_UNDERFLOW"] = 16] = "ME_UNDERFLOW";
})(ME = exports.ME || (exports.ME = {}));
exports.mapErr = new Map([
    [ME.ME_NONE, 'No error'],
    [ME.ME_DOMAIN, "argument out of domain in '%s'"],
    [ME.ME_RANGE, "argument out of domain in '%s'"],
    [ME.ME_NOCONV, "convergence failed in '%s'"],
    [ME.ME_PRECISION, "full precision may not have been achieved in '%s'"],
    [ME.ME_UNDERFLOW, "underflow occurred in '%s'"]
]);
exports.ML_ERROR = function (x, s, printer) {
    var str = exports.mapErr.get(x);
    if (str) {
        printer(str, s);
    }
};
function ML_ERR_return_NAN(printer) {
    exports.ML_ERROR(ME.ME_DOMAIN, '', printer);
    return Number.NaN;
}
exports.ML_ERR_return_NAN = ML_ERR_return_NAN;
function R_D_nonint_check(log, x, printer) {
    if (R_nonint(x)) {
        printer('non-integer x = %d', x);
        return exports.R_D__0(log);
    }
    return undefined;
}
exports.R_D_nonint_check = R_D_nonint_check;
function fmod(x, y) {
    return x - Math.trunc(x / y) * y;
}
exports.fmod = fmod;
function imax2(x, y) {
    return Math.trunc(Math.max(x, y));
}
exports.imax2 = imax2;
function isOdd(k) {
    return Math.floor(k) % 2 === 1;
}
exports.isOdd = isOdd;
function epsilonNear(x, target) {
    if (Number.isNaN(x))
        return x;
    if (!isFinite(x))
        return x;
    if (Number.isNaN(target))
        return x;
    if (!isFinite(target))
        return x;
    var diff = x - target;
    if (diff > Number.EPSILON || diff < -Number.EPSILON) {
        return x;
    }
    return target;
}
exports.epsilonNear = epsilonNear;
function isEpsilonNear(x, target) {
    if (isFinite(x) && isFinite(target))
        return epsilonNear(x, target) === target;
    return false;
}
exports.isEpsilonNear = isEpsilonNear;
function R_D_negInonint(x) {
    return x < 0.0 || R_nonint(x);
}
exports.R_D_negInonint = R_D_negInonint;
function R_nonint(x) {
    return !Number.isInteger(x);
}
exports.R_nonint = R_nonint;
function R_D_fexp(give_log, f, x) {
    return give_log ? -0.5 * Math.log(f) + x : Math.exp(x) / Math.sqrt(f);
}
exports.R_D_fexp = R_D_fexp;
exports.nsig_BESS = 16;
exports.ensig_BESS = 1e16;
exports.rtnsig_BESS = 1e-4;
exports.enmten_BESS = 8.9e-308;
exports.enten_BESS = 1e308;
exports.exparg_BESS = 709;
exports.xlrg_BESS_IJ = 1e5;
exports.xlrg_BESS_Y = 1e8;
exports.thresh_BESS_Y = 16;
exports.xmax_BESS_K = 705.342;
exports.sqxmin_BESS_K = 1.49e-154;
exports.M_eps_sinc = 2.149e-8;
function R_pow_di(x, n) {
    var pow = 1.0;
    if (Number.isNaN(x))
        return x;
    if (n !== 0) {
        if (!Number.isFinite(x))
            return R_pow(x, n);
        if (n < 0) {
            n = -n;
            x = 1 / x;
        }
        while (true) {
            if (n & 1)
                pow *= x;
            if ((n >>= 1))
                x *= x;
            else
                break;
        }
    }
    return pow;
}
exports.R_pow_di = R_pow_di;
function R_pow(x, y) {
    if (y === 2.0)
        return x * x;
    if (x === 1 || y === 0)
        return 1;
    if (x === 0) {
        if (y > 0)
            return 0;
        else if (y < 0)
            return Number.POSITIVE_INFINITY;
        else
            return y;
    }
    if (Number.isFinite(x) && Number.isFinite(y)) {
        return Math.pow(x, y);
    }
    if (Number.isNaN(x) || Number.isNaN(y))
        return x + y;
    if (!Number.isFinite(x)) {
        if (x > 0)
            return y < 0 ? 0 : Number.POSITIVE_INFINITY;
        else {
            if (Number.isFinite(y) && y === Math.floor(y))
                return y < 0 ? 0 : myfmod(y, 2) ? x : -x;
        }
    }
    if (!Number.isFinite(y)) {
        if (x >= 0) {
            if (y > 0)
                return x >= 1 ? Number.POSITIVE_INFINITY : 0;
            else
                return x < 1 ? Number.POSITIVE_INFINITY : 0;
        }
    }
    return NaN;
}
exports.R_pow = R_pow;
exports.R_finite = function (x) { return !Number.isFinite(x); };
exports.R_isnancpp = function (x) { return Number.isNaN(x); };
function myfmod(x1, x2) {
    var q = x1 / x2;
    return x1 - Math.floor(q) * x2;
}
exports.myfmod = myfmod;
function R_powV(x, y) {
    if (x === 1 || y === 0)
        return 1;
    if (x === 0) {
        if (y > 0)
            return 0;
        return Number.POSITIVE_INFINITY;
    }
    if (Number.isFinite(x) && Number.isFinite(y))
        return Math.pow(x, y);
    if (Number.isNaN(x) || Number.isNaN(y)) {
        return x + y;
    }
    if (!Number.isFinite(x)) {
        if (x > 0)
            return y < 0 ? 0 : Number.POSITIVE_INFINITY;
        else {
            if (Number.isFinite(y) && y === Math.floor(y))
                return y < 0 ? 0 : myfmod(y, 2) ? x : -x;
        }
    }
    if (!Number.isFinite(y)) {
        if (x >= 0) {
            if (y > 0)
                return x >= 1 ? Number.POSITIVE_INFINITY : 0;
            else
                return x < 1 ? Number.POSITIVE_INFINITY : 0;
        }
    }
    return NaN;
}
exports.R_powV = R_powV;
function ldexp(x, y) {
    if (Number.isNaN(x) || Number.isNaN(y)) {
        return x + y;
    }
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
        return Number.POSITIVE_INFINITY;
    }
    return x * Math.pow(2, y);
}
exports.ldexp = ldexp;
function R_D_log(log_p, p) {
    return log_p ? p : Math.log(p);
}
exports.R_D_log = R_D_log;
function R_Q_P01_boundaries(lower_tail, log_p, p, _LEFT_, _RIGHT_) {
    if (log_p) {
        if (p > 0) {
            return ML_ERR_return_NAN(debug_R_Q_P01_boundaries);
        }
        if (p === 0)
            return lower_tail ? _RIGHT_ : _LEFT_;
        if (p === Number.NEGATIVE_INFINITY)
            return lower_tail ? _LEFT_ : _RIGHT_;
    }
    else {
        if (p < 0 || p > 1) {
            return ML_ERR_return_NAN(debug_R_Q_P01_boundaries);
        }
        if (p === 0)
            return lower_tail ? _LEFT_ : _RIGHT_;
        if (p === 1)
            return lower_tail ? _RIGHT_ : _LEFT_;
    }
    return undefined;
}
exports.R_Q_P01_boundaries = R_Q_P01_boundaries;
function R_Q_P01_check(logP, p) {
    if ((logP && p > 0) || (!logP && (p < 0 || p > 1))) {
        return ML_ERR_return_NAN(debug_R_Q_P01_check);
    }
    return undefined;
}
exports.R_Q_P01_check = R_Q_P01_check;
function R_D_qIv(logP, p) {
    return logP ? Math.exp(p) : p;
}
exports.R_D_qIv = R_D_qIv;
//# sourceMappingURL=_general.js.map