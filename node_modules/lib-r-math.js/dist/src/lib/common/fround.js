"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var R_rint = Math.round;
var _general_1 = require("../common/_general");
var LONG_MAX = Number.MAX_SAFE_INTEGER, DBL_EPSILON = Number.EPSILON, ML_POSINF = Number.POSITIVE_INFINITY, ISNAN = Number.isNaN, ML_NEGINF = Number.NEGATIVE_INFINITY, R_FINITE = Number.isFinite;
var fabs = Math.abs, floor = Math.floor;
var MAX_DIGITS = Math.trunc(Math.log10(Number.MAX_VALUE));
function private_rint(x) {
    var tmp;
    var sgn = 1.0;
    var ltmp;
    if (x !== x) {
        return x;
    }
    if (x < 0.0) {
        x = -x;
        sgn = -1.0;
    }
    if (x < LONG_MAX) {
        ltmp = x + 0.5;
        if (fabs(x + 0.5 - ltmp) < 10 * DBL_EPSILON && ltmp % 2 === 1)
            ltmp--;
        tmp = ltmp;
    }
    else {
        tmp = floor(x + 0.5);
    }
    return sgn * tmp;
}
exports.private_rint = private_rint;
function fround(x, digits) {
    var pow10;
    var sgn;
    var intx;
    var dig;
    if (ISNAN(x) || ISNAN(digits))
        return x + digits;
    if (!R_FINITE(x))
        return x;
    if (digits === ML_POSINF)
        return x;
    else if (digits === ML_NEGINF)
        return 0.0;
    if (digits > MAX_DIGITS)
        digits = MAX_DIGITS;
    dig = floor(digits + 0.5);
    if (x < 0) {
        sgn = -1;
        x = -x;
    }
    else
        sgn = 1;
    if (dig === 0) {
        return sgn * R_rint(x);
    }
    else if (dig > 0) {
        pow10 = _general_1.R_pow_di(10, dig);
        intx = floor(x);
        return sgn * (intx + R_rint((x - intx) * pow10) / pow10);
    }
    else {
        pow10 = _general_1.R_pow_di(10, -dig);
        return sgn * R_rint(x / pow10) * pow10;
    }
}
exports.fround = fround;
//# sourceMappingURL=fround.js.map