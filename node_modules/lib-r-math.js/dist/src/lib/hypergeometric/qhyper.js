"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var debug = require("debug");
var _general_1 = require("../common/_general");
var choose_1 = require("../common/choose");
var expm1_1 = require("../exp/expm1");
var log = Math.log, exp = Math.exp, fmin2 = Math.min, fmax2 = Math.max, R_forceint = Math.round;
var ISNAN = Number.isNaN, R_FINITE = Number.isFinite, DBL_EPSILON = Number.EPSILON;
var printer_qhyper = debug('qhyper');
function qhyper(p, nr, nb, n, lowerTail, logP) {
    if (lowerTail === void 0) { lowerTail = true; }
    if (logP === void 0) { logP = false; }
    var N;
    var xstart;
    var xend;
    var xr;
    var xb;
    var sum;
    var term;
    var small_N;
    if (ISNAN(p) || ISNAN(nr) || ISNAN(nb) || ISNAN(n))
        return NaN;
    if (!R_FINITE(nr) || !R_FINITE(nb) || !R_FINITE(n))
        return _general_1.ML_ERR_return_NAN(printer_qhyper);
    var NR = R_forceint(nr);
    var NB = R_forceint(nb);
    N = NR + NB;
    n = R_forceint(n);
    if (NR < 0 || NB < 0 || n < 0 || n > N)
        return _general_1.ML_ERR_return_NAN(printer_qhyper);
    xstart = fmax2(0, n - NB);
    xend = fmin2(n, NR);
    var rc = _general_1.R_Q_P01_boundaries(lowerTail, logP, p, xstart, xend);
    if (rc !== undefined) {
        return rc;
    }
    xr = xstart;
    xb = n - xr;
    small_N = N < 1000;
    term = choose_1.lfastchoose(NR, xr) + choose_1.lfastchoose(NB, xb) - choose_1.lfastchoose(N, n);
    if (small_N)
        term = exp(term);
    NR -= xr;
    NB -= xb;
    if (!lowerTail || logP) {
        p = expm1_1.R_DT_qIv(lowerTail, logP, p);
    }
    p *= 1 - 1000 * DBL_EPSILON;
    sum = small_N ? term : exp(term);
    while (sum < p && xr < xend) {
        xr++;
        NB++;
        if (small_N)
            term *= NR / xr * (xb / NB);
        else
            term += log(NR / xr * (xb / NB));
        sum += small_N ? term : exp(term);
        xb--;
        NR--;
    }
    return xr;
}
exports.qhyper = qhyper;
//# sourceMappingURL=qhyper.js.map